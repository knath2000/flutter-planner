// Generated by dart2js (NullSafetyMode.sound, trust primitives, omit checks, lax runtime type, csp, intern-composite-values), the Dart to JavaScript compiler version: 3.7.2.
((s, d, e) => {
  s[d] = s[d] || {};
  s[d][e] = s[d][e] || [];
  s[d][e].push({p: "main.dart.js_2", e: "beginPart"});
})(self, "$__dart_deferred_initializers__", "eventLog");
$__dart_deferred_initializers__.current = function(hunkHelpers, init, holdersList, $) {
  var J, B, C,
  A = {
    SplayTreeMap$($K, $V) {
      var t1 = B._defaultCompare($K);
      return new A.SplayTreeMap(t1, $K._eval$1("@<0>")._bind$1($V)._eval$1("SplayTreeMap<1,2>"));
    },
    _SplayTreeMapNode: function _SplayTreeMapNode(t0, t1, t2) {
      var _ = this;
      _.value = t0;
      _.key = t1;
      _._collection$_right = _._collection$_left = null;
      _.$ti = t2;
    },
    SplayTreeMap: function SplayTreeMap(t0, t1) {
      var _ = this;
      _._collection$_root = null;
      _._compare = t0;
      _._splayCount = _._modificationCount = _._collection$_count = 0;
      _.$ti = t1;
    },
    _SplayTreeKeyIterable: function _SplayTreeKeyIterable(t0, t1) {
      this._tree = t0;
      this.$ti = t1;
    },
    _SplayTreeValueIterable: function _SplayTreeValueIterable(t0, t1) {
      this._collection$_map = t0;
      this.$ti = t1;
    },
    _SplayTreeMapEntryIterable: function _SplayTreeMapEntryIterable(t0, t1) {
      this._collection$_map = t0;
      this.$ti = t1;
    },
    _SplayTreeValueIterator: function _SplayTreeValueIterator(t0, t1, t2, t3) {
      var _ = this;
      _._collection$_current = null;
      _._tree = t0;
      _._collection$_path = t1;
      _._modificationCount = null;
      _._splayCount = t2;
      _.$ti = t3;
    },
    _SplayTreeMapEntryIterator: function _SplayTreeMapEntryIterator(t0, t1, t2, t3) {
      var _ = this;
      _._collection$_current = null;
      _._tree = t0;
      _._collection$_path = t1;
      _._modificationCount = null;
      _._splayCount = t2;
      _.$ti = t3;
    },
    _SplayTreeMap__SplayTree_MapMixin: function _SplayTreeMap__SplayTree_MapMixin() {
    },
    RenderIndexedSemantics: function RenderIndexedSemantics(t0, t1, t2, t3) {
      var _ = this;
      _._proxy_box$_index = t0;
      _.RenderObjectWithChildMixin__child = t1;
      _._layoutCacheStorage = t2;
      _.parentData = _._box$_size = null;
      _._depth = 0;
      _._object$_owner = _._object$_parent = null;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _.__RenderObject__wasRepaintBoundary_A = $;
      _._layerHandle = t3;
      _._needsCompositingBitsUpdate = false;
      _.__RenderObject__needsCompositing_A = $;
      _._needsPaint = true;
      _._needsCompositedLayerUpdate = false;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
    },
    applyGrowthDirectionToScrollDirection(scrollDirection, growthDirection) {
      var t1;
      switch (growthDirection.index) {
        case 0:
          t1 = scrollDirection;
          break;
        case 1:
          t1 = A.flipScrollDirection(scrollDirection);
          break;
        default:
          t1 = null;
      }
      return t1;
    },
    SliverGeometry$(cacheExtent, hasVisualOverflow, hitTestExtent, layoutExtent, maxPaintExtent, paintExtent, paintOrigin, scrollExtent, scrollOffsetCorrection) {
      var t1 = layoutExtent == null ? paintExtent : layoutExtent,
        t2 = hitTestExtent == null ? paintExtent : hitTestExtent,
        t3 = cacheExtent == null ? layoutExtent : cacheExtent;
      if (t3 == null)
        t3 = paintExtent;
      return new A.SliverGeometry(scrollExtent, paintOrigin, paintExtent, t1, maxPaintExtent, t2, paintExtent > 0, hasVisualOverflow, scrollOffsetCorrection, t3);
    },
    SliverConstraints: function SliverConstraints(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) {
      var _ = this;
      _.axisDirection = t0;
      _.growthDirection = t1;
      _.userScrollDirection = t2;
      _.scrollOffset = t3;
      _.precedingScrollExtent = t4;
      _.overlap = t5;
      _.remainingPaintExtent = t6;
      _.crossAxisExtent = t7;
      _.crossAxisDirection = t8;
      _.viewportMainAxisExtent = t9;
      _.cacheOrigin = t10;
      _.remainingCacheExtent = t11;
    },
    SliverGeometry: function SliverGeometry(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {
      var _ = this;
      _.scrollExtent = t0;
      _.paintOrigin = t1;
      _.paintExtent = t2;
      _.layoutExtent = t3;
      _.maxPaintExtent = t4;
      _.hitTestExtent = t5;
      _.visible = t6;
      _.hasVisualOverflow = t7;
      _.scrollOffsetCorrection = t8;
      _.cacheExtent = t9;
    },
    SliverHitTestResult: function SliverHitTestResult(t0, t1, t2) {
      this._path = t0;
      this._transforms = t1;
      this._localTransforms = t2;
    },
    SliverHitTestEntry: function SliverHitTestEntry(t0, t1, t2) {
      var _ = this;
      _.mainAxisPosition = t0;
      _.crossAxisPosition = t1;
      _.target = t2;
      _._transform = null;
    },
    SliverLogicalParentData: function SliverLogicalParentData() {
    },
    SliverPhysicalParentData: function SliverPhysicalParentData(t0) {
      this.paintOffset = t0;
    },
    SliverPhysicalContainerParentData: function SliverPhysicalContainerParentData(t0, t1, t2) {
      this.ContainerParentDataMixin_previousSibling = t0;
      this.ContainerParentDataMixin_nextSibling = t1;
      this.paintOffset = t2;
    },
    RenderSliver: function RenderSliver() {
    },
    RenderSliverHelpers: function RenderSliverHelpers() {
    },
    RenderSliverHelpers_hitTestBoxChild_closure: function RenderSliverHelpers_hitTestBoxChild_closure(t0, t1) {
      this._box_0 = t0;
      this.child = t1;
    },
    _SliverGeometry_Object_Diagnosticable: function _SliverGeometry_Object_Diagnosticable() {
    },
    _SliverPhysicalContainerParentData_SliverPhysicalParentData_ContainerParentDataMixin: function _SliverPhysicalContainerParentData_SliverPhysicalParentData_ContainerParentDataMixin() {
    },
    RenderSliverList: function RenderSliverList(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._childManager = t0;
      _._keepAliveBucket = t1;
      _.ContainerRenderObjectMixin__childCount = t2;
      _.ContainerRenderObjectMixin__firstChild = t3;
      _.ContainerRenderObjectMixin__lastChild = t4;
      _.parentData = _._geometry = null;
      _._depth = 0;
      _._object$_owner = _._object$_parent = null;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _.__RenderObject__wasRepaintBoundary_A = $;
      _._layerHandle = t5;
      _._needsCompositingBitsUpdate = false;
      _.__RenderObject__needsCompositing_A = $;
      _._needsPaint = true;
      _._needsCompositedLayerUpdate = false;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
    },
    RenderSliverList_performLayout_advance: function RenderSliverList_performLayout_advance(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.childConstraints = t2;
    },
    KeepAliveParentDataMixin: function KeepAliveParentDataMixin() {
    },
    RenderSliverWithKeepAliveMixin: function RenderSliverWithKeepAliveMixin() {
    },
    SliverMultiBoxAdaptorParentData: function SliverMultiBoxAdaptorParentData(t0, t1, t2) {
      var _ = this;
      _.index = null;
      _._keptAlive = false;
      _.KeepAliveParentDataMixin_keepAlive = t0;
      _.ContainerParentDataMixin_previousSibling = t1;
      _.ContainerParentDataMixin_nextSibling = t2;
      _.layoutOffset = null;
    },
    RenderSliverMultiBoxAdaptor: function RenderSliverMultiBoxAdaptor() {
    },
    RenderSliverMultiBoxAdaptor__createOrObtainChild_closure: function RenderSliverMultiBoxAdaptor__createOrObtainChild_closure(t0, t1, t2) {
      this.$this = t0;
      this.index = t1;
      this.after = t2;
    },
    RenderSliverMultiBoxAdaptor_collectGarbage_closure: function RenderSliverMultiBoxAdaptor_collectGarbage_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    RenderSliverMultiBoxAdaptor_collectGarbage__closure: function RenderSliverMultiBoxAdaptor_collectGarbage__closure() {
    },
    _RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin: function _RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin() {
    },
    _RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers: function _RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers() {
    },
    _RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers_RenderSliverWithKeepAliveMixin: function _RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers_RenderSliverWithKeepAliveMixin() {
    },
    _SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin: function _SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin() {
    },
    _SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin_KeepAliveParentDataMixin: function _SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin_KeepAliveParentDataMixin() {
    },
    RenderSliverEdgeInsetsPadding: function RenderSliverEdgeInsetsPadding() {
    },
    RenderSliverEdgeInsetsPadding_performLayout_paintOffset: function RenderSliverEdgeInsetsPadding_performLayout_paintOffset(t0, t1) {
      this.$this = t0;
      this.constraints = t1;
    },
    RenderSliverEdgeInsetsPadding_performLayout_cacheOffset: function RenderSliverEdgeInsetsPadding_performLayout_cacheOffset(t0, t1) {
      this.$this = t0;
      this.constraints = t1;
    },
    RenderSliverPadding: function RenderSliverPadding(t0, t1, t2, t3) {
      var _ = this;
      _._resolvedPadding = null;
      _._sliver_padding$_padding = t0;
      _._sliver_padding$_textDirection = t1;
      _.RenderObjectWithChildMixin__child = t2;
      _.parentData = _._geometry = null;
      _._depth = 0;
      _._object$_owner = _._object$_parent = null;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _.__RenderObject__wasRepaintBoundary_A = $;
      _._layerHandle = t3;
      _._needsCompositingBitsUpdate = false;
      _.__RenderObject__needsCompositing_A = $;
      _._needsPaint = true;
      _._needsCompositedLayerUpdate = false;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
    },
    _RenderSliverEdgeInsetsPadding_RenderSliver_RenderObjectWithChildMixin: function _RenderSliverEdgeInsetsPadding_RenderSliver_RenderObjectWithChildMixin() {
    },
    CacheExtentStyle: function CacheExtentStyle(t0, t1) {
      this.index = t0;
      this._name = t1;
    },
    RenderViewportBase: function RenderViewportBase() {
    },
    RenderViewportBase_visitChildrenForSemantics_closure: function RenderViewportBase_visitChildrenForSemantics_closure() {
    },
    RenderViewportBase_hitTestChildren_closure: function RenderViewportBase_hitTestChildren_closure(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.child = t2;
      _.sliverResult = t3;
    },
    RenderViewport: function RenderViewport(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) {
      var _ = this;
      _._anchor = t0;
      _._center = null;
      _.__RenderViewport__maxScrollExtent_A = _.__RenderViewport__minScrollExtent_A = $;
      _._viewport$_hasVisualOverflow = false;
      _._axisDirection = t1;
      _._crossAxisDirection = t2;
      _._viewport$_offset = t3;
      _._cacheExtent = t4;
      _._calculatedCacheExtent = null;
      _._cacheExtentStyle = t5;
      _._viewport$_clipBehavior = t6;
      _._viewport$_clipRectLayer = t7;
      _.ContainerRenderObjectMixin__childCount = t8;
      _.ContainerRenderObjectMixin__firstChild = t9;
      _.ContainerRenderObjectMixin__lastChild = t10;
      _._layoutCacheStorage = t11;
      _.parentData = _._box$_size = null;
      _._depth = 0;
      _._object$_owner = _._object$_parent = null;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _.__RenderObject__wasRepaintBoundary_A = $;
      _._layerHandle = t12;
      _._needsCompositingBitsUpdate = false;
      _.__RenderObject__needsCompositing_A = $;
      _._needsPaint = true;
      _._needsCompositedLayerUpdate = false;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
    },
    _RenderViewportBase_RenderBox_ContainerRenderObjectMixin: function _RenderViewportBase_RenderBox_ContainerRenderObjectMixin() {
    },
    AutomaticKeepAlive: function AutomaticKeepAlive(t0, t1) {
      this.child = t0;
      this.key = t1;
    },
    _AutomaticKeepAliveState: function _AutomaticKeepAliveState() {
      var _ = this;
      _._automatic_keep_alive$_handles = null;
      _.___AutomaticKeepAliveState__child_A = $;
      _._keepingAlive = false;
      _._framework$_element = _._widget = null;
    },
    _AutomaticKeepAliveState__addClient_closure: function _AutomaticKeepAliveState__addClient_closure(t0) {
      this.$this = t0;
    },
    _AutomaticKeepAliveState__getChildElement_closure: function _AutomaticKeepAliveState__getChildElement_closure(t0) {
      this._box_0 = t0;
    },
    _AutomaticKeepAliveState__createCallback_closure: function _AutomaticKeepAliveState__createCallback_closure(t0, t1, t2) {
      this.$this = t0;
      this.handle = t1;
      this.callback = t2;
    },
    _AutomaticKeepAliveState__createCallback__closure: function _AutomaticKeepAliveState__createCallback__closure(t0) {
      this.$this = t0;
    },
    _AutomaticKeepAliveState__createCallback__closure0: function _AutomaticKeepAliveState__createCallback__closure0(t0) {
      this.$this = t0;
    },
    _AutomaticKeepAliveState__createCallback___closure: function _AutomaticKeepAliveState__createCallback___closure() {
    },
    SliverPadding: function SliverPadding(t0, t1, t2) {
      this.padding = t0;
      this.child = t1;
      this.key = t2;
    },
    IndexedSemantics: function IndexedSemantics(t0, t1, t2) {
      this.index = t0;
      this.child = t1;
      this.key = t2;
    },
    _kDefaultSemanticIndexCallback(__wc0_formal, localIndex) {
      return localIndex;
    },
    SliverChildDelegate: function SliverChildDelegate() {
    },
    _SaltedValueKey: function _SaltedValueKey(t0) {
      this.value = t0;
    },
    SliverChildBuilderDelegate: function SliverChildBuilderDelegate(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.builder = t0;
      _.childCount = t1;
      _.addAutomaticKeepAlives = t2;
      _.addRepaintBoundaries = t3;
      _.addSemanticIndexes = t4;
      _.findChildIndexCallback = t5;
    },
    _SelectionKeepAlive: function _SelectionKeepAlive(t0, t1) {
      this.child = t0;
      this.key = t1;
    },
    _SelectionKeepAliveState: function _SelectionKeepAliveState(t0) {
      var _ = this;
      _._scroll_delegate$_registrar = _._selectableAttachments = _._selectablesWithSelections = null;
      _._wantKeepAlive = false;
      _.AutomaticKeepAliveClientMixin__keepAliveHandle = t0;
      _._framework$_element = _._widget = null;
    },
    _SelectionKeepAliveState_listensTo_closure: function _SelectionKeepAliveState_listensTo_closure(t0, t1) {
      this.$this = t0;
      this.selectable = t1;
    },
    __SelectionKeepAliveState_State_AutomaticKeepAliveClientMixin: function __SelectionKeepAliveState_State_AutomaticKeepAliveClientMixin() {
    },
    ListView$builder(itemBuilder, itemCount, padding, physics) {
      var _null = null;
      return new A.ListView(new A.SliverChildBuilderDelegate(itemBuilder, itemCount, true, true, true, _null), padding, C.Axis_1, false, _null, _null, physics, false, _null, itemCount, C.DragStartBehavior_1, G.ScrollViewKeyboardDismissBehavior_0, _null, C.Clip_1, C.HitTestBehavior_1, _null);
    },
    ScrollView: function ScrollView() {
    },
    ScrollView_build_closure: function ScrollView_build_closure(t0, t1, t2) {
      this.$this = t0;
      this.axisDirection = t1;
      this.slivers = t2;
    },
    ScrollView_build_closure0: function ScrollView_build_closure0(t0) {
      this.context = t0;
    },
    BoxScrollView: function BoxScrollView() {
    },
    ListView: function ListView(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15) {
      var _ = this;
      _.childrenDelegate = t0;
      _.padding = t1;
      _.scrollDirection = t2;
      _.reverse = t3;
      _.controller = t4;
      _.primary = t5;
      _.physics = t6;
      _.shrinkWrap = t7;
      _.cacheExtent = t8;
      _.semanticChildCount = t9;
      _.dragStartBehavior = t10;
      _.keyboardDismissBehavior = t11;
      _.restorationId = t12;
      _.clipBehavior = t13;
      _.hitTestBehavior = t14;
      _.key = t15;
    },
    SliverMultiBoxAdaptorElement$(widget, replaceMovedChildren) {
      return new A.SliverMultiBoxAdaptorElement(replaceMovedChildren, A.SplayTreeMap$(type$.int, type$.nullable_Element), widget, C._ElementLifecycle_0);
    },
    SliverMultiBoxAdaptorElement__extrapolateMaxScrollOffset(firstIndex, lastIndex, leadingScrollOffset, trailingScrollOffset, childCount) {
      if (lastIndex === childCount - 1)
        return trailingScrollOffset;
      return trailingScrollOffset + (trailingScrollOffset - leadingScrollOffset) / (lastIndex - firstIndex + 1) * (childCount - lastIndex - 1);
    },
    KeepAlive$(child, keepAlive) {
      return new A.KeepAlive(keepAlive, child, null);
    },
    SliverWithKeepAliveWidget: function SliverWithKeepAliveWidget() {
    },
    SliverMultiBoxAdaptorWidget: function SliverMultiBoxAdaptorWidget() {
    },
    SliverList: function SliverList(t0, t1) {
      this.delegate = t0;
      this.key = t1;
    },
    SliverMultiBoxAdaptorElement: function SliverMultiBoxAdaptorElement(t0, t1, t2, t3) {
      var _ = this;
      _._replaceMovedChildren = t0;
      _._childElements = t1;
      _._currentlyUpdatingChildIndex = _._currentBeforeChild = null;
      _._didUnderflow = false;
      _._slot = _._notificationTree = _._framework$_parent = _._ancestorRenderObjectElement = _._renderObject = null;
      _.__Element__depth_A = $;
      _._widget = t2;
      _._parentBuildScope = _._framework$_owner = null;
      _._lifecycleState = t3;
      _._dependencies = _._inheritedElements = null;
      _._hadUnsatisfiedDependencies = false;
      _._dirty = true;
      _._inDirtyList = false;
    },
    SliverMultiBoxAdaptorElement_performRebuild_processElement: function SliverMultiBoxAdaptorElement_performRebuild_processElement(t0, t1, t2, t3, t4) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.newChildren = t2;
      _.adaptorWidget = t3;
      _.indexToLayoutOffset = t4;
    },
    SliverMultiBoxAdaptorElement_performRebuild_closure: function SliverMultiBoxAdaptorElement_performRebuild_closure() {
    },
    SliverMultiBoxAdaptorElement_performRebuild_closure0: function SliverMultiBoxAdaptorElement_performRebuild_closure0(t0, t1) {
      this.$this = t0;
      this.index = t1;
    },
    SliverMultiBoxAdaptorElement_createChild_closure: function SliverMultiBoxAdaptorElement_createChild_closure(t0, t1, t2) {
      this.$this = t0;
      this.after = t1;
      this.index = t2;
    },
    SliverMultiBoxAdaptorElement_removeChild_closure: function SliverMultiBoxAdaptorElement_removeChild_closure(t0, t1) {
      this.$this = t0;
      this.index = t1;
    },
    KeepAlive: function KeepAlive(t0, t1, t2) {
      this.keepAlive = t0;
      this.child = t1;
      this.key = t2;
    },
    Viewport_getDefaultCrossAxisDirection(context, axisDirection) {
      switch (axisDirection.index) {
        case 0:
          return E.textDirectionToAxisDirection(context.dependOnInheritedWidgetOfExactType$1$0(type$.Directionality).textDirection);
        case 1:
          return C.AxisDirection_2;
        case 2:
          return E.textDirectionToAxisDirection(context.dependOnInheritedWidgetOfExactType$1$0(type$.Directionality).textDirection);
        case 3:
          return C.AxisDirection_2;
      }
    },
    Viewport: function Viewport(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _.axisDirection = t0;
      _.anchor = t1;
      _.offset = t2;
      _.center = t3;
      _.cacheExtent = t4;
      _.clipBehavior = t5;
      _.children = t6;
      _.key = t7;
    },
    _ViewportElement: function _ViewportElement(t0, t1, t2) {
      var _ = this;
      _._doingMountOrUpdate = false;
      _._centerSlotIndex = null;
      _.__MultiChildRenderObjectElement__children_A = $;
      _._forgottenChildren = t0;
      _._slot = _._notificationTree = _._framework$_parent = _._ancestorRenderObjectElement = _._renderObject = null;
      _.__Element__depth_A = $;
      _._widget = t1;
      _._parentBuildScope = _._framework$_owner = null;
      _._lifecycleState = t2;
      _._dependencies = _._inheritedElements = null;
      _._hadUnsatisfiedDependencies = false;
      _._dirty = true;
      _._inDirtyList = false;
    },
    __ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin: function __ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin() {
    },
    __ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin_ViewportElementMixin: function __ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin_ViewportElementMixin() {
    },
    AnimateWidgetExtensions_animate(_this) {
      var _null = null,
        t1 = new A.Animate(_this, _null, _null, _null, true, C.Duration_0, _null, _null, _null, _null, C.Duration_0, C.Duration_0, _null);
      A.warn(true, "Animate.onPlay is not called when Animate.autoPlay=false");
      A.warn(true, "Animate.onInit is not called when used with Animate.controller");
      t1.__Animate__entries_F = B._setArrayType([], type$.JSArray_EffectEntry);
      return t1;
    },
    Animate: function Animate(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) {
      var _ = this;
      _.child = t0;
      _.onInit = t1;
      _.onPlay = t2;
      _.onComplete = t3;
      _.autoPlay = t4;
      _.delay = t5;
      _.controller = t6;
      _.adapter = t7;
      _.target = t8;
      _.value = t9;
      _.__Animate__entries_F = $;
      _._animate$_duration = t10;
      _._lastEntry = null;
      _._baseDelay = t11;
      _.key = t12;
    },
    Animate_reparentTypes_closure: function Animate_reparentTypes_closure() {
    },
    Animate_reparentTypes_closure0: function Animate_reparentTypes_closure0() {
    },
    Animate_reparentTypes_closure1: function Animate_reparentTypes_closure1() {
    },
    _AnimateState: function _AnimateState(t0, t1) {
      var _ = this;
      _.___AnimateState__controller_A = $;
      _._isInternalController = false;
      _._delayed = _._adapter = null;
      _.SingleTickerProviderStateMixin__ticker = t0;
      _.SingleTickerProviderStateMixin__tickerModeNotifier = t1;
      _._framework$_element = _._widget = null;
    },
    _AnimateState__restart_closure: function _AnimateState__restart_closure(t0) {
      this.$this = t0;
    },
    _Animate_StatefulWidget_AnimateManager: function _Animate_StatefulWidget_AnimateManager() {
    },
    __AnimateState_State_SingleTickerProviderStateMixin: function __AnimateState_State_SingleTickerProviderStateMixin() {
    },
    Effect: function Effect() {
    },
    FadeEffectExtensions_fadeIn(_this, delay, duration) {
      return _this.addEffect$1(new A.FadeEffect(delay, duration, null, 0, 1));
    },
    FadeEffect: function FadeEffect(t0, t1, t2, t3, t4) {
      var _ = this;
      _.delay = t0;
      _.duration = t1;
      _.curve = t2;
      _.begin = t3;
      _.end = t4;
    },
    SlideEffect$(begin, curve, delay, duration, end) {
      return new A.SlideEffect(delay, duration, curve, begin, end);
    },
    SlideEffect: function SlideEffect(t0, t1, t2, t3, t4) {
      var _ = this;
      _.delay = t0;
      _.duration = t1;
      _.curve = t2;
      _.begin = t3;
      _.end = t4;
    },
    AnimateManager: function AnimateManager() {
    },
    EffectEntry: function EffectEntry(t0, t1, t2, t3) {
      var _ = this;
      _.delay = t0;
      _.duration = t1;
      _.curve = t2;
      _.effect = t3;
    },
    tasksForProjectProvider_closure: function tasksForProjectProvider_closure() {
    },
    ProviderFamilyBuilder: function ProviderFamilyBuilder() {
    },
    StreamProviderFamilyBuilder: function StreamProviderFamilyBuilder() {
    },
    Family: function Family() {
    },
    _FamilyMixin: function _FamilyMixin() {
    },
    FamilyBase: function FamilyBase() {
    },
    FamilyBase_call_closure: function FamilyBase_call_closure(t0, t1) {
      this.$this = t0;
      this.argument = t1;
    },
    _FamilyBase_Family__FamilyMixin: function _FamilyBase_Family__FamilyMixin() {
    },
    Provider___internal_tearOff(_createFn, allTransitiveDependencies, argument, debugGetCreateSourceHash, dependencies, from, $name, State) {
      return new B.Provider(_createFn, from, argument, $name, dependencies, allTransitiveDependencies, State._eval$1("Provider<0>"));
    },
    ProviderFamily: function ProviderFamily(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._providerFactory = t0;
      _._framework0$_createFn = t1;
      _.name = t2;
      _.dependencies = t3;
      _.allTransitiveDependencies = t4;
      _.debugGetCreateSourceHash = t5;
      _.$ti = t6;
    },
    StreamProvider___internal_tearOff(_createFn, allTransitiveDependencies, argument, debugGetCreateSourceHash, dependencies, from, $name, $T) {
      return new B.StreamProvider(_createFn, from, argument, $name, dependencies, allTransitiveDependencies, $T._eval$1("StreamProvider<0>"));
    },
    StreamProviderFamily: function StreamProviderFamily(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._providerFactory = t0;
      _._framework0$_createFn = t1;
      _.name = t2;
      _.dependencies = t3;
      _.allTransitiveDependencies = t4;
      _.debugGetCreateSourceHash = t5;
      _.$ti = t6;
    },
    flipScrollDirection(direction) {
      var t1;
      switch (direction.index) {
        case 0:
          t1 = C.ScrollDirection_0;
          break;
        case 1:
          t1 = C.ScrollDirection_2;
          break;
        case 2:
          t1 = C.ScrollDirection_1;
          break;
        default:
          t1 = null;
      }
      return t1;
    },
    OffsetCopyWithExtensions_copyWith(_this, dx, dy) {
      var t1 = dx == null ? _this._dx : dx;
      return new B.Offset(t1, dy == null ? _this._dy : dy);
    },
    warn(condition, message) {
      if (condition)
        return;
      B.print__debugPrintThrottled$closure().call$1("\x1b[48;5;229m\x1b[38;5;0m[flutter_animate] " + message + "\x1b[0m");
    }
  },
  D, E, G, F, H;
  J = holdersList[1];
  B = holdersList[0];
  C = holdersList[2];
  A = hunkHelpers.updateHolder(holdersList[8], A);
  D = holdersList[17];
  E = holdersList[11];
  G = holdersList[20];
  F = holdersList[12];
  H = holdersList[19];
  A._SplayTreeMapNode.prototype = {};
  A.SplayTreeMap.prototype = {
    $index(_, key) {
      var t1 = this._untypedLookup$1(key);
      return t1 == null ? null : t1.value;
    },
    remove$1(_, key) {
      var root = this._untypedLookup$1(key);
      if (root == null)
        return null;
      this._removeRoot$0();
      return root.value;
    },
    $indexSet(_, key, value) {
      var _this = this,
        comparison = _this._splay$1(key);
      if (comparison === 0) {
        _this._collection$_root.value = value;
        return;
      }
      _this._addNewRoot$2(new A._SplayTreeMapNode(value, key, _this.$ti._eval$1("_SplayTreeMapNode<1,2>")), comparison);
    },
    putIfAbsent$2(key, ifAbsent) {
      var originalModificationCount, originalSplayCount, value, _this = this,
        comparison = _this._splay$1(key);
      if (comparison === 0)
        return _this._collection$_root.value;
      originalModificationCount = _this._modificationCount;
      originalSplayCount = _this._splayCount;
      value = ifAbsent.call$0();
      if (originalModificationCount !== _this._modificationCount || originalSplayCount !== _this._splayCount) {
        comparison = _this._splay$1(key);
        if (comparison === 0)
          return _this._collection$_root.value = value;
      }
      _this._addNewRoot$2(new A._SplayTreeMapNode(value, key, _this.$ti._eval$1("_SplayTreeMapNode<1,2>")), comparison);
      return value;
    },
    updateAll$1(update) {
      var t1, t2, iterator, node, newValue, _this = this;
      if (_this._collection$_root == null)
        return;
      t1 = _this.$ti;
      t2 = B._setArrayType([], t1._eval$1("JSArray<_SplayTreeMapNode<1,2>>"));
      iterator = new A._SplayTreeMapEntryIterator(_this, t2, _this._splayCount, t1._eval$1("_SplayTreeMapEntryIterator<1,2>"));
      while (true) {
        iterator._collection$_current = null;
        if (!iterator.super$_SplayTreeIterator$moveNext())
          break;
        node = iterator.get$current();
        newValue = update.call$2(node.key, node.value);
        if (iterator._modificationCount !== _this._modificationCount)
          B.throwExpression(B.ConcurrentModificationError$(_this));
        if (iterator._splayCount !== _this._splayCount)
          iterator._rebuildPath$1(C.JSArray_methods.get$last(t2).key);
        C.JSArray_methods.get$last(t2).value = newValue;
      }
    },
    get$isEmpty(_) {
      return this._collection$_root == null;
    },
    get$isNotEmpty(_) {
      return this._collection$_root != null;
    },
    forEach$1(_, f) {
      var node,
        t1 = this.$ti,
        nodes = new A._SplayTreeMapEntryIterator(this, B._setArrayType([], t1._eval$1("JSArray<_SplayTreeMapNode<1,2>>")), this._splayCount, t1._eval$1("_SplayTreeMapEntryIterator<1,2>"));
      while (true) {
        nodes._collection$_current = null;
        if (!nodes.super$_SplayTreeIterator$moveNext())
          break;
        node = nodes.get$current();
        f.call$2(node.key, node.value);
      }
    },
    get$length(_) {
      return this._collection$_count;
    },
    containsKey$1(key) {
      return this._untypedLookup$1(key) != null;
    },
    get$keys() {
      return new A._SplayTreeKeyIterable(this, this.$ti._eval$1("_SplayTreeKeyIterable<1,_SplayTreeMapNode<1,2>>"));
    },
    get$values() {
      return new A._SplayTreeValueIterable(this, this.$ti._eval$1("_SplayTreeValueIterable<1,2>"));
    },
    get$entries() {
      return new A._SplayTreeMapEntryIterable(this, this.$ti._eval$1("_SplayTreeMapEntryIterable<1,2>"));
    },
    firstKey$0() {
      var t1,
        root = this._collection$_root;
      if (root == null)
        return null;
      t1 = this._splayMin$1(root);
      this._collection$_root = t1;
      return t1.key;
    },
    lastKey$0() {
      var t1,
        root = this._collection$_root;
      if (root == null)
        return null;
      t1 = this._splayMax$1(root);
      this._collection$_root = t1;
      return t1.key;
    },
    $isMap: 1,
    _compare$2(arg0, arg1) {
      return this._compare.call$2(arg0, arg1);
    },
    get$_collection$_root() {
      return this._collection$_root;
    },
    get$_compare() {
      return this._compare;
    },
    get$_validKey() {
      return null;
    },
    set$_collection$_root(val) {
      return this._collection$_root = val;
    }
  };
  A._SplayTreeKeyIterable.prototype = {
    get$length(_) {
      return this._tree._collection$_count;
    },
    get$isEmpty(_) {
      return this._tree._collection$_count === 0;
    },
    get$iterator(_) {
      var t1 = this._tree,
        t2 = this.$ti;
      return new B._SplayTreeKeyIterator(t1, B._setArrayType([], t2._eval$1("JSArray<2>")), t1._splayCount, t2._eval$1("_SplayTreeKeyIterator<1,2>"));
    },
    contains$1(_, element) {
      return this._tree._untypedLookup$1(element) != null;
    },
    toSet$0(_) {
      var t1 = this._tree,
        set = B.SplayTreeSet$(t1._compare, null, this.$ti._precomputed1),
        root = t1._collection$_root;
      if (root != null) {
        set._collection$_root = set._copyNode$1(root);
        set._collection$_count = t1._collection$_count;
      }
      return set;
    }
  };
  A._SplayTreeValueIterable.prototype = {
    get$length(_) {
      return this._collection$_map._collection$_count;
    },
    get$isEmpty(_) {
      return this._collection$_map._collection$_count === 0;
    },
    get$iterator(_) {
      var t1 = this._collection$_map,
        t2 = this.$ti;
      return new A._SplayTreeValueIterator(t1, B._setArrayType([], t2._eval$1("JSArray<_SplayTreeMapNode<1,2>>")), t1._splayCount, t2._eval$1("_SplayTreeValueIterator<1,2>"));
    }
  };
  A._SplayTreeMapEntryIterable.prototype = {
    get$length(_) {
      return this._collection$_map._collection$_count;
    },
    get$isEmpty(_) {
      return this._collection$_map._collection$_count === 0;
    },
    get$iterator(_) {
      var t1 = this._collection$_map,
        t2 = this.$ti;
      return new A._SplayTreeMapEntryIterator(t1, B._setArrayType([], t2._eval$1("JSArray<_SplayTreeMapNode<1,2>>")), t1._splayCount, t2._eval$1("_SplayTreeMapEntryIterator<1,2>"));
    }
  };
  A._SplayTreeValueIterator.prototype = {
    moveNext$0() {
      var result = this.super$_SplayTreeIterator$moveNext();
      this._collection$_current = result ? C.JSArray_methods.get$last(this._collection$_path).value : null;
      return result;
    },
    _getValue$1(node) {
      var t1 = this._collection$_current;
      return t1 == null ? this.$ti._rest[1]._as(t1) : t1;
    }
  };
  A._SplayTreeMapEntryIterator.prototype = {
    _getValue$1(node) {
      var t1 = this._collection$_current;
      return t1 == null ? this._collection$_current = new B.MapEntry(node.key, node.value, this.$ti._eval$1("MapEntry<1,2>")) : t1;
    },
    moveNext$0() {
      this._collection$_current = null;
      return this.super$_SplayTreeIterator$moveNext();
    }
  };
  A._SplayTreeMap__SplayTree_MapMixin.prototype = {};
  A.RenderIndexedSemantics.prototype = {
    set$index(value) {
      if (value === this._proxy_box$_index)
        return;
      this._proxy_box$_index = value;
      this.markNeedsSemanticsUpdate$0();
    },
    describeSemanticsConfiguration$1(config) {
      this.super$RenderObject$describeSemanticsConfiguration(config);
      config._indexInParent = this._proxy_box$_index;
      config._hasBeenAnnotated = true;
    }
  };
  A.SliverConstraints.prototype = {
    get$isTight() {
      return false;
    },
    asBoxConstraints$2$maxExtent$minExtent(maxExtent, minExtent) {
      var crossAxisExtent = this.crossAxisExtent;
      switch (B.axisDirectionToAxis(this.axisDirection).index) {
        case 0:
          return new B.BoxConstraints(minExtent, maxExtent, crossAxisExtent, crossAxisExtent);
        case 1:
          return new B.BoxConstraints(crossAxisExtent, crossAxisExtent, minExtent, maxExtent);
      }
    },
    asBoxConstraints$0() {
      return this.asBoxConstraints$2$maxExtent$minExtent(1 / 0, 0);
    },
    $eq(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!(other instanceof A.SliverConstraints))
        return false;
      return other.axisDirection === _this.axisDirection && other.growthDirection === _this.growthDirection && other.userScrollDirection === _this.userScrollDirection && other.scrollOffset === _this.scrollOffset && other.precedingScrollExtent === _this.precedingScrollExtent && other.overlap === _this.overlap && other.remainingPaintExtent === _this.remainingPaintExtent && other.crossAxisExtent === _this.crossAxisExtent && other.crossAxisDirection === _this.crossAxisDirection && other.viewportMainAxisExtent === _this.viewportMainAxisExtent && other.remainingCacheExtent === _this.remainingCacheExtent && other.cacheOrigin === _this.cacheOrigin;
    },
    get$hashCode(_) {
      var _this = this;
      return B.Object_hash(_this.axisDirection, _this.growthDirection, _this.userScrollDirection, _this.scrollOffset, _this.precedingScrollExtent, _this.overlap, _this.remainingPaintExtent, _this.crossAxisExtent, _this.crossAxisDirection, _this.viewportMainAxisExtent, _this.remainingCacheExtent, _this.cacheOrigin, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue);
    },
    toString$0(_) {
      var _this = this,
        t1 = B._setArrayType([_this.axisDirection.toString$0(0), _this.growthDirection.toString$0(0), _this.userScrollDirection.toString$0(0), "scrollOffset: " + C.JSNumber_methods.toStringAsFixed$1(_this.scrollOffset, 1), "precedingScrollExtent: " + C.JSNumber_methods.toStringAsFixed$1(_this.precedingScrollExtent, 1), "remainingPaintExtent: " + C.JSNumber_methods.toStringAsFixed$1(_this.remainingPaintExtent, 1)], type$.JSArray_String),
        t2 = _this.overlap;
      if (t2 !== 0)
        t1.push("overlap: " + C.JSNumber_methods.toStringAsFixed$1(t2, 1));
      t1.push("crossAxisExtent: " + C.JSNumber_methods.toStringAsFixed$1(_this.crossAxisExtent, 1));
      t1.push("crossAxisDirection: " + _this.crossAxisDirection.toString$0(0));
      t1.push("viewportMainAxisExtent: " + C.JSNumber_methods.toStringAsFixed$1(_this.viewportMainAxisExtent, 1));
      t1.push("remainingCacheExtent: " + C.JSNumber_methods.toStringAsFixed$1(_this.remainingCacheExtent, 1));
      t1.push("cacheOrigin: " + C.JSNumber_methods.toStringAsFixed$1(_this.cacheOrigin, 1));
      return "SliverConstraints(" + C.JSArray_methods.join$1(t1, ", ") + ")";
    }
  };
  A.SliverGeometry.prototype = {
    toStringShort$0() {
      return "SliverGeometry";
    }
  };
  A.SliverHitTestResult.prototype = {};
  A.SliverHitTestEntry.prototype = {
    toString$0(_) {
      return B.getRuntimeTypeOfDartObject(this.target).toString$0(0) + "@(mainAxis: " + B.S(this.mainAxisPosition) + ", crossAxis: " + B.S(this.crossAxisPosition) + ")";
    }
  };
  A.SliverLogicalParentData.prototype = {
    toString$0(_) {
      var t1 = this.layoutOffset;
      return "layoutOffset=" + (t1 == null ? "None" : C.JSNumber_methods.toStringAsFixed$1(t1, 1));
    }
  };
  A.SliverPhysicalParentData.prototype = {
    toString$0(_) {
      return "paintOffset=" + this.paintOffset.toString$0(0);
    }
  };
  A.SliverPhysicalContainerParentData.prototype = {};
  A.RenderSliver.prototype = {
    get$constraints() {
      return type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(this));
    },
    get$semanticBounds() {
      return this.get$paintBounds();
    },
    get$paintBounds() {
      var _this = this,
        t1 = type$.SliverConstraints;
      switch (B.axisDirectionToAxis(t1._as(B.RenderObject.prototype.get$constraints.call(_this)).axisDirection).index) {
        case 0:
          return new B.Rect(0, 0, 0 + _this._geometry.paintExtent, 0 + t1._as(B.RenderObject.prototype.get$constraints.call(_this)).crossAxisExtent);
        case 1:
          return new B.Rect(0, 0, 0 + t1._as(B.RenderObject.prototype.get$constraints.call(_this)).crossAxisExtent, 0 + _this._geometry.paintExtent);
      }
    },
    performResize$0() {
    },
    hitTest$3$crossAxisPosition$mainAxisPosition(result, crossAxisPosition, mainAxisPosition) {
      var t1, _this = this;
      if (mainAxisPosition >= 0 && mainAxisPosition < _this._geometry.hitTestExtent && crossAxisPosition >= 0 && crossAxisPosition < type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(_this)).crossAxisExtent) {
        t1 = _this.hitTestChildren$3$crossAxisPosition$mainAxisPosition(result, crossAxisPosition, mainAxisPosition);
        if (t1) {
          result.add$1(0, new A.SliverHitTestEntry(mainAxisPosition, crossAxisPosition, _this));
          return true;
        }
      }
      return false;
    },
    hitTestChildren$3$crossAxisPosition$mainAxisPosition(result, crossAxisPosition, mainAxisPosition) {
      return false;
    },
    calculatePaintOffset$3$from$to(constraints, from, to) {
      var a = constraints.scrollOffset,
        t1 = constraints.remainingPaintExtent,
        b = a + t1;
      return B.clampDouble(B.clampDouble(to, a, b) - B.clampDouble(from, a, b), 0, t1);
    },
    calculateCacheOffset$3$from$to(constraints, from, to) {
      var t1 = constraints.scrollOffset,
        a = t1 + constraints.cacheOrigin,
        t2 = constraints.remainingCacheExtent,
        b = t1 + t2;
      return B.clampDouble(B.clampDouble(to, a, b) - B.clampDouble(from, a, b), 0, t2);
    },
    childScrollOffset$1(child) {
      return 0;
    },
    applyPaintTransform$2(child, transform) {
    },
    handleEvent$2($event, entry) {
    }
  };
  A.RenderSliverHelpers.prototype = {
    _getRightWayUp$1(constraints) {
      var t1,
        reversed = B.axisDirectionIsReversed(constraints.axisDirection);
      switch (constraints.growthDirection.index) {
        case 0:
          t1 = !reversed;
          break;
        case 1:
          t1 = reversed;
          break;
        default:
          t1 = null;
      }
      return t1;
    },
    hitTestBoxChild$4$crossAxisPosition$mainAxisPosition(result, child, crossAxisPosition, mainAxisPosition) {
      var delta, absolutePosition, paintOffset, _this = this, _box_0 = {},
        t1 = type$.SliverConstraints,
        rightWayUp = _this._getRightWayUp$1(t1._as(B.RenderObject.prototype.get$constraints.call(_this))),
        t2 = child.parentData;
      t2.toString;
      t2 = type$.SliverMultiBoxAdaptorParentData._as(t2).layoutOffset;
      t2.toString;
      delta = t2 - t1._as(B.RenderObject.prototype.get$constraints.call(_this)).scrollOffset;
      absolutePosition = mainAxisPosition - delta;
      paintOffset = _box_0.transformedPosition = null;
      switch (B.axisDirectionToAxis(t1._as(B.RenderObject.prototype.get$constraints.call(_this)).axisDirection).index) {
        case 0:
          if (!rightWayUp) {
            absolutePosition = child.get$size()._dx - absolutePosition;
            delta = _this._geometry.paintExtent - child.get$size()._dx - delta;
          }
          paintOffset = new B.Offset(delta, 0);
          _box_0.transformedPosition = new B.Offset(absolutePosition, crossAxisPosition);
          break;
        case 1:
          if (!rightWayUp) {
            absolutePosition = child.get$size()._dy - absolutePosition;
            delta = _this._geometry.paintExtent - child.get$size()._dy - delta;
          }
          paintOffset = new B.Offset(0, delta);
          _box_0.transformedPosition = new B.Offset(crossAxisPosition, absolutePosition);
          break;
      }
      return result.addWithOutOfBandPosition$2$hitTest$paintOffset(new A.RenderSliverHelpers_hitTestBoxChild_closure(_box_0, child), paintOffset);
    },
    applyPaintTransformForBoxChild$2(child, transform) {
      var delta, _this = this,
        t1 = type$.SliverConstraints,
        rightWayUp = _this._getRightWayUp$1(t1._as(B.RenderObject.prototype.get$constraints.call(_this))),
        t2 = child.parentData;
      t2.toString;
      t2 = type$.SliverMultiBoxAdaptorParentData._as(t2).layoutOffset;
      t2.toString;
      delta = t2 - t1._as(B.RenderObject.prototype.get$constraints.call(_this)).scrollOffset;
      switch (B.axisDirectionToAxis(t1._as(B.RenderObject.prototype.get$constraints.call(_this)).axisDirection).index) {
        case 0:
          transform.translate$2(!rightWayUp ? _this._geometry.paintExtent - child.get$size()._dx - delta : delta, 0);
          break;
        case 1:
          transform.translate$2(0, !rightWayUp ? _this._geometry.paintExtent - child.get$size()._dy - delta : delta);
          break;
      }
    }
  };
  A._SliverGeometry_Object_Diagnosticable.prototype = {};
  A._SliverPhysicalContainerParentData_SliverPhysicalParentData_ContainerParentDataMixin.prototype = {
    detach$0() {
      this.super$ParentData$detach();
    }
  };
  A.RenderSliverList.prototype = {
    performLayout$0() {
      var t2, scrollOffset, targetEndScrollOffset, childConstraints, earliestUsefulChild, t3, t4, leadingChildrenWithoutLayoutOffset, t5, earliestScrollOffset, leadingChildWithLayout, firstChildScrollOffset, advance, leadingGarbage, extent, reachedEnd, trailingGarbage, child, estimatedMaxScrollOffset, t6, paintExtent, cacheExtent, _this = this, _null = null, _box_0 = {},
        constraints = type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(_this)),
        t1 = _this._childManager;
      t1._didUnderflow = false;
      t2 = constraints.scrollOffset;
      scrollOffset = t2 + constraints.cacheOrigin;
      targetEndScrollOffset = scrollOffset + constraints.remainingCacheExtent;
      childConstraints = constraints.asBoxConstraints$0();
      if (_this.ContainerRenderObjectMixin__firstChild == null)
        if (!_this.addInitialChild$0()) {
          _this._geometry = D.SliverGeometry_QEo;
          t1.didFinishLayout$0();
          return;
        }
      _box_0.trailingChildWithLayout = null;
      earliestUsefulChild = _this.ContainerRenderObjectMixin__firstChild;
      t3 = earliestUsefulChild.parentData;
      t3.toString;
      t4 = type$.SliverMultiBoxAdaptorParentData;
      if (t4._as(t3).layoutOffset == null) {
        t3 = B._instanceType(_this)._eval$1("ContainerRenderObjectMixin.1");
        leadingChildrenWithoutLayoutOffset = 0;
        while (true) {
          if (earliestUsefulChild != null) {
            t5 = earliestUsefulChild.parentData;
            t5.toString;
            t5 = t4._as(t5).layoutOffset == null;
          } else
            t5 = false;
          if (!t5)
            break;
          t5 = earliestUsefulChild.parentData;
          t5.toString;
          earliestUsefulChild = t3._as(t5).ContainerParentDataMixin_nextSibling;
          ++leadingChildrenWithoutLayoutOffset;
        }
        _this.collectGarbage$2(leadingChildrenWithoutLayoutOffset, 0);
        if (_this.ContainerRenderObjectMixin__firstChild == null)
          if (!_this.addInitialChild$0()) {
            _this._geometry = D.SliverGeometry_QEo;
            t1.didFinishLayout$0();
            return;
          }
      }
      earliestUsefulChild = _this.ContainerRenderObjectMixin__firstChild;
      t3 = earliestUsefulChild.parentData;
      t3.toString;
      t3 = t4._as(t3).layoutOffset;
      t3.toString;
      earliestScrollOffset = t3;
      leadingChildWithLayout = _null;
      for (; earliestScrollOffset > scrollOffset; earliestScrollOffset = firstChildScrollOffset, leadingChildWithLayout = earliestUsefulChild) {
        earliestUsefulChild = _this.insertAndLayoutLeadingChild$2$parentUsesSize(childConstraints, true);
        if (earliestUsefulChild == null) {
          t3 = _this.ContainerRenderObjectMixin__firstChild;
          t5 = t3.parentData;
          t5.toString;
          t4._as(t5).layoutOffset = 0;
          if (scrollOffset === 0) {
            t3.layout$2$parentUsesSize(childConstraints, true);
            earliestUsefulChild = _this.ContainerRenderObjectMixin__firstChild;
            if (_box_0.trailingChildWithLayout == null)
              _box_0.trailingChildWithLayout = earliestUsefulChild;
            leadingChildWithLayout = earliestUsefulChild;
            break;
          } else {
            _this._geometry = A.SliverGeometry$(_null, false, _null, _null, 0, 0, 0, 0, -scrollOffset);
            return;
          }
        }
        t3 = _this.ContainerRenderObjectMixin__firstChild;
        t3.toString;
        firstChildScrollOffset = earliestScrollOffset - _this.paintExtentOf$1(t3);
        if (firstChildScrollOffset < -1e-10) {
          _this._geometry = A.SliverGeometry$(_null, false, _null, _null, 0, 0, 0, 0, -firstChildScrollOffset);
          t1 = _this.ContainerRenderObjectMixin__firstChild.parentData;
          t1.toString;
          t4._as(t1).layoutOffset = 0;
          return;
        }
        t3 = earliestUsefulChild.parentData;
        t3.toString;
        t4._as(t3).layoutOffset = firstChildScrollOffset;
        if (_box_0.trailingChildWithLayout == null)
          _box_0.trailingChildWithLayout = earliestUsefulChild;
      }
      if (scrollOffset < 1e-10)
        while (true) {
          t3 = _this.ContainerRenderObjectMixin__firstChild;
          t3.toString;
          t3 = t3.parentData;
          t3.toString;
          t4._as(t3);
          t5 = t3.index;
          t5.toString;
          if (!(t5 > 0))
            break;
          t3 = t3.layoutOffset;
          t3.toString;
          earliestUsefulChild = _this.insertAndLayoutLeadingChild$2$parentUsesSize(childConstraints, true);
          t5 = _this.ContainerRenderObjectMixin__firstChild;
          t5.toString;
          firstChildScrollOffset = t3 - _this.paintExtentOf$1(t5);
          t5 = _this.ContainerRenderObjectMixin__firstChild.parentData;
          t5.toString;
          t4._as(t5).layoutOffset = 0;
          if (firstChildScrollOffset < -1e-10) {
            _this._geometry = A.SliverGeometry$(_null, false, _null, _null, 0, 0, 0, 0, -firstChildScrollOffset);
            return;
          }
        }
      if (leadingChildWithLayout == null) {
        earliestUsefulChild.layout$2$parentUsesSize(childConstraints, true);
        _box_0.trailingChildWithLayout = earliestUsefulChild;
      }
      _box_0.inLayoutRange = true;
      _box_0.child = earliestUsefulChild;
      t3 = earliestUsefulChild.parentData;
      t3.toString;
      t4._as(t3);
      t5 = t3.index;
      t5.toString;
      _box_0.index = t5;
      t3 = t3.layoutOffset;
      t3.toString;
      _box_0.endScrollOffset = t3 + _this.paintExtentOf$1(earliestUsefulChild);
      advance = new A.RenderSliverList_performLayout_advance(_box_0, _this, childConstraints);
      for (leadingGarbage = 0; _box_0.endScrollOffset < scrollOffset;) {
        ++leadingGarbage;
        if (!advance.call$0()) {
          _this.collectGarbage$2(leadingGarbage - 1, 0);
          t1 = _this.ContainerRenderObjectMixin__lastChild;
          t2 = t1.parentData;
          t2.toString;
          t2 = t4._as(t2).layoutOffset;
          t2.toString;
          extent = t2 + _this.paintExtentOf$1(t1);
          _this._geometry = A.SliverGeometry$(_null, false, _null, _null, extent, 0, 0, extent, _null);
          return;
        }
      }
      while (true) {
        if (!(_box_0.endScrollOffset < targetEndScrollOffset)) {
          reachedEnd = false;
          break;
        }
        if (!advance.call$0()) {
          reachedEnd = true;
          break;
        }
      }
      t3 = _box_0.child;
      trailingGarbage = 0;
      if (t3 != null) {
        t3 = t3.parentData;
        t3.toString;
        t5 = B._instanceType(_this)._eval$1("ContainerRenderObjectMixin.1");
        t3 = _box_0.child = t5._as(t3).ContainerParentDataMixin_nextSibling;
        for (; t3 != null; t3 = child) {
          ++trailingGarbage;
          t3 = t3.parentData;
          t3.toString;
          child = t5._as(t3).ContainerParentDataMixin_nextSibling;
          _box_0.child = child;
        }
      }
      _this.collectGarbage$2(leadingGarbage, trailingGarbage);
      estimatedMaxScrollOffset = _box_0.endScrollOffset;
      if (!reachedEnd) {
        t3 = _this.ContainerRenderObjectMixin__firstChild;
        t3.toString;
        t3 = t3.parentData;
        t3.toString;
        t4._as(t3);
        t5 = t3.index;
        t5.toString;
        t6 = _this.ContainerRenderObjectMixin__lastChild;
        t6.toString;
        t6 = t6.parentData;
        t6.toString;
        t6 = t4._as(t6).index;
        t6.toString;
        estimatedMaxScrollOffset = t1.estimateMaxScrollOffset$5$firstIndex$lastIndex$leadingScrollOffset$trailingScrollOffset(constraints, t5, t6, t3.layoutOffset, estimatedMaxScrollOffset);
      }
      t3 = _this.ContainerRenderObjectMixin__firstChild.parentData;
      t3.toString;
      t3 = t4._as(t3).layoutOffset;
      t3.toString;
      paintExtent = _this.calculatePaintOffset$3$from$to(constraints, t3, _box_0.endScrollOffset);
      t3 = _this.ContainerRenderObjectMixin__firstChild.parentData;
      t3.toString;
      t3 = t4._as(t3).layoutOffset;
      t3.toString;
      cacheExtent = _this.calculateCacheOffset$3$from$to(constraints, t3, _box_0.endScrollOffset);
      t3 = _box_0.endScrollOffset;
      _this._geometry = A.SliverGeometry$(cacheExtent, t3 > t2 + constraints.remainingPaintExtent || t2 > 0, _null, _null, estimatedMaxScrollOffset, paintExtent, 0, estimatedMaxScrollOffset, _null);
      if (estimatedMaxScrollOffset === t3)
        t1._didUnderflow = true;
      t1.didFinishLayout$0();
    }
  };
  A.KeepAliveParentDataMixin.prototype = {$isParentData: 1};
  A.RenderSliverWithKeepAliveMixin.prototype = {
    setupParentData$1(child) {
    }
  };
  A.SliverMultiBoxAdaptorParentData.prototype = {
    toString$0(_) {
      var t1 = this.index,
        t2 = this.KeepAliveParentDataMixin_keepAlive ? "keepAlive; " : "";
      return "index=" + B.S(t1) + "; " + t2 + this.super$SliverLogicalParentData$toString(0);
    }
  };
  A.RenderSliverMultiBoxAdaptor.prototype = {
    setupParentData$1(child) {
      if (!(child.parentData instanceof A.SliverMultiBoxAdaptorParentData))
        child.parentData = new A.SliverMultiBoxAdaptorParentData(false, null, null);
    },
    adoptChild$1(child) {
      var t1;
      this.super$RenderObject$adoptChild(child);
      t1 = child.parentData;
      t1.toString;
      if (!type$.SliverMultiBoxAdaptorParentData._as(t1)._keptAlive)
        this._childManager.didAdoptChild$1(type$.RenderBox._as(child));
    },
    insert$2$after(_, child, after) {
      this.super$ContainerRenderObjectMixin$insert(0, child, after);
    },
    move$2$after(child, after) {
      var t2, _this = this,
        t1 = child.parentData;
      t1.toString;
      type$.SliverMultiBoxAdaptorParentData._as(t1);
      if (!t1._keptAlive) {
        _this.super$ContainerRenderObjectMixin$move(child, after);
        _this._childManager.didAdoptChild$1(child);
        _this.markNeedsLayout$0();
      } else {
        t2 = _this._keepAliveBucket;
        if (t2.$index(0, t1.index) === child)
          t2.remove$1(0, t1.index);
        _this._childManager.didAdoptChild$1(child);
        t1 = t1.index;
        t1.toString;
        t2.$indexSet(0, t1, child);
      }
    },
    remove$1(_, child) {
      var t1 = child.parentData;
      t1.toString;
      type$.SliverMultiBoxAdaptorParentData._as(t1);
      if (!t1._keptAlive) {
        this.super$ContainerRenderObjectMixin$remove(0, child);
        return;
      }
      this._keepAliveBucket.remove$1(0, t1.index);
      this.dropChild$1(child);
    },
    _createOrObtainChild$2$after(index, after) {
      this.invokeLayoutCallback$1$1(new A.RenderSliverMultiBoxAdaptor__createOrObtainChild_closure(this, index, after), type$.SliverConstraints);
    },
    _destroyOrCacheChild$1(child) {
      var t2, _this = this,
        t1 = child.parentData;
      t1.toString;
      type$.SliverMultiBoxAdaptorParentData._as(t1);
      if (t1.KeepAliveParentDataMixin_keepAlive) {
        _this.remove$1(0, child);
        t2 = t1.index;
        t2.toString;
        _this._keepAliveBucket.$indexSet(0, t2, child);
        child.parentData = t1;
        _this.super$RenderObject$adoptChild(child);
        t1._keptAlive = true;
      } else
        _this._childManager.removeChild$1(child);
    },
    attach$1(owner) {
      var t1;
      this.super$_RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin$attach(owner);
      for (t1 = this._keepAliveBucket, t1 = new B.LinkedHashMapValueIterator(t1, t1._modifications, t1._first); t1.moveNext$0();)
        t1.__js_helper$_current.attach$1(owner);
    },
    detach$0() {
      this.super$_RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin$detach();
      for (var t1 = this._keepAliveBucket, t1 = new B.LinkedHashMapValueIterator(t1, t1._modifications, t1._first); t1.moveNext$0();)
        t1.__js_helper$_current.detach$0();
    },
    redepthChildren$0() {
      this.super$ContainerRenderObjectMixin$redepthChildren();
      var t1 = this._keepAliveBucket;
      new B.LinkedHashMapValuesIterable(t1, B._instanceType(t1)._eval$1("LinkedHashMapValuesIterable<2>")).forEach$1(0, this.get$redepthChild());
    },
    visitChildren$1(visitor) {
      var t1;
      this.super$ContainerRenderObjectMixin$visitChildren(visitor);
      t1 = this._keepAliveBucket;
      new B.LinkedHashMapValuesIterable(t1, B._instanceType(t1)._eval$1("LinkedHashMapValuesIterable<2>")).forEach$1(0, visitor);
    },
    visitChildrenForSemantics$1(visitor) {
      this.super$ContainerRenderObjectMixin$visitChildren(visitor);
    },
    addInitialChild$2$index$layoutOffset(index, layoutOffset) {
      var t1;
      this._createOrObtainChild$2$after(index, null);
      t1 = this.ContainerRenderObjectMixin__firstChild;
      if (t1 != null) {
        t1 = t1.parentData;
        t1.toString;
        type$.SliverMultiBoxAdaptorParentData._as(t1).layoutOffset = layoutOffset;
        return true;
      }
      this._childManager._didUnderflow = true;
      return false;
    },
    addInitialChild$0() {
      return this.addInitialChild$2$index$layoutOffset(0, 0);
    },
    insertAndLayoutLeadingChild$2$parentUsesSize(childConstraints, parentUsesSize) {
      var t2, index, t3, _this = this,
        t1 = _this.ContainerRenderObjectMixin__firstChild;
      t1.toString;
      t1 = t1.parentData;
      t1.toString;
      t2 = type$.SliverMultiBoxAdaptorParentData;
      t1 = t2._as(t1).index;
      t1.toString;
      index = t1 - 1;
      _this._createOrObtainChild$2$after(index, null);
      t1 = _this.ContainerRenderObjectMixin__firstChild;
      t1.toString;
      t3 = t1.parentData;
      t3.toString;
      t3 = t2._as(t3).index;
      t3.toString;
      if (t3 === index) {
        t1.layout$2$parentUsesSize(childConstraints, parentUsesSize);
        return _this.ContainerRenderObjectMixin__firstChild;
      }
      _this._childManager._didUnderflow = true;
      return null;
    },
    insertAndLayoutChild$3$after$parentUsesSize(childConstraints, after, parentUsesSize) {
      var t2, index, child,
        t1 = after.parentData;
      t1.toString;
      t2 = type$.SliverMultiBoxAdaptorParentData;
      t1 = t2._as(t1).index;
      t1.toString;
      index = t1 + 1;
      this._createOrObtainChild$2$after(index, after);
      t1 = after.parentData;
      t1.toString;
      child = B._instanceType(this)._eval$1("ContainerRenderObjectMixin.1")._as(t1).ContainerParentDataMixin_nextSibling;
      if (child != null) {
        t1 = child.parentData;
        t1.toString;
        t1 = t2._as(t1).index;
        t1.toString;
        t1 = t1 === index;
      } else
        t1 = false;
      if (t1) {
        child.layout$2$parentUsesSize(childConstraints, parentUsesSize);
        return child;
      }
      this._childManager._didUnderflow = true;
      return null;
    },
    collectGarbage$2(leadingGarbage, trailingGarbage) {
      var t1 = {};
      t1.leadingGarbage = leadingGarbage;
      t1.trailingGarbage = trailingGarbage;
      this.invokeLayoutCallback$1$1(new A.RenderSliverMultiBoxAdaptor_collectGarbage_closure(t1, this), type$.SliverConstraints);
    },
    paintExtentOf$1(child) {
      var t1;
      switch (B.axisDirectionToAxis(type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(this)).axisDirection).index) {
        case 0:
          t1 = child.get$size()._dx;
          break;
        case 1:
          t1 = child.get$size()._dy;
          break;
        default:
          t1 = null;
      }
      return t1;
    },
    hitTestChildren$3$crossAxisPosition$mainAxisPosition(result, crossAxisPosition, mainAxisPosition) {
      var t1, t2,
        child = this.ContainerRenderObjectMixin__lastChild,
        boxResult = B.BoxHitTestResult$wrap(result);
      for (t1 = B._instanceType(this)._eval$1("ContainerRenderObjectMixin.1"); child != null;) {
        if (this.hitTestBoxChild$4$crossAxisPosition$mainAxisPosition(boxResult, child, crossAxisPosition, mainAxisPosition))
          return true;
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_previousSibling;
      }
      return false;
    },
    childScrollOffset$1(child) {
      var t1 = child.parentData;
      t1.toString;
      return type$.SliverMultiBoxAdaptorParentData._as(t1).layoutOffset;
    },
    paintsChild$1(child) {
      var childParentData = type$.nullable_SliverMultiBoxAdaptorParentData._as(child.parentData);
      return (childParentData == null ? null : childParentData.index) != null && !this._keepAliveBucket.containsKey$1(childParentData.index);
    },
    applyPaintTransform$2(child, transform) {
      if (!this.paintsChild$1(child))
        transform.setZero$0();
      else
        this.applyPaintTransformForBoxChild$2(child, transform);
    },
    paint$2(context, offset) {
      var t1, addExtent, originOffset, mainAxisUnit, crossAxisUnit, child, t2, t3, t4, mainAxisDelta, t5, t6, t7, childOffset, t8, _this = this, _null = null;
      if (_this.ContainerRenderObjectMixin__firstChild == null)
        return;
      t1 = type$.SliverConstraints;
      addExtent = true;
      switch (B.applyGrowthDirectionToAxisDirection(t1._as(B.RenderObject.prototype.get$constraints.call(_this)).axisDirection, t1._as(B.RenderObject.prototype.get$constraints.call(_this)).growthDirection).index) {
        case 0:
          originOffset = offset.$add(0, new B.Offset(0, _this._geometry.paintExtent));
          mainAxisUnit = C.Offset_0_m1;
          crossAxisUnit = C.Offset_1_0;
          break;
        case 1:
          originOffset = offset;
          mainAxisUnit = C.Offset_1_0;
          crossAxisUnit = C.Offset_0_1;
          addExtent = false;
          break;
        case 2:
          originOffset = offset;
          mainAxisUnit = C.Offset_0_1;
          crossAxisUnit = C.Offset_1_0;
          addExtent = false;
          break;
        case 3:
          originOffset = offset.$add(0, new B.Offset(_this._geometry.paintExtent, 0));
          mainAxisUnit = C.Offset_m1_0;
          crossAxisUnit = C.Offset_0_1;
          break;
        default:
          addExtent = _null;
          originOffset = addExtent;
          crossAxisUnit = originOffset;
          mainAxisUnit = crossAxisUnit;
      }
      child = _this.ContainerRenderObjectMixin__firstChild;
      for (t2 = B._instanceType(_this)._eval$1("ContainerRenderObjectMixin.1"), t3 = type$.SliverMultiBoxAdaptorParentData; child != null;) {
        t4 = child.parentData;
        t4.toString;
        t4 = t3._as(t4).layoutOffset;
        t4.toString;
        mainAxisDelta = t4 - t1._as(B.RenderObject.prototype.get$constraints.call(_this)).scrollOffset;
        t4 = originOffset._dx;
        t5 = mainAxisUnit._dx;
        t4 = t4 + t5 * mainAxisDelta + crossAxisUnit._dx * 0;
        t6 = originOffset._dy;
        t7 = mainAxisUnit._dy;
        t6 = t6 + t7 * mainAxisDelta + crossAxisUnit._dy * 0;
        childOffset = new B.Offset(t4, t6);
        if (addExtent) {
          t8 = _this.paintExtentOf$1(child);
          childOffset = new B.Offset(t4 + t5 * t8, t6 + t7 * t8);
        }
        if (mainAxisDelta < t1._as(B.RenderObject.prototype.get$constraints.call(_this)).remainingPaintExtent && mainAxisDelta + _this.paintExtentOf$1(child) > 0)
          context.paintChild$2(child, childOffset);
        t4 = child.parentData;
        t4.toString;
        child = t2._as(t4).ContainerParentDataMixin_nextSibling;
      }
    },
    debugDescribeChildren$0() {
      var t1, t2, indices, _i, index, t3,
        _s17_ = "child with index ",
        children = B._setArrayType([], type$.JSArray_DiagnosticsNode),
        child = this.ContainerRenderObjectMixin__firstChild;
      if (child != null)
        for (t1 = type$.SliverMultiBoxAdaptorParentData; true;) {
          t2 = child.parentData;
          t2.toString;
          t1._as(t2);
          children.push(new B.DiagnosticableTreeNode(child, _s17_ + B.S(t2.index), true, true, null, null));
          if (child == this.ContainerRenderObjectMixin__lastChild)
            break;
          child = t2.ContainerParentDataMixin_nextSibling;
        }
      t1 = this._keepAliveBucket;
      if (t1.__js_helper$_length !== 0) {
        t2 = B._instanceType(t1)._eval$1("LinkedHashMapKeysIterable<1>");
        indices = B.List_List$of(new B.LinkedHashMapKeysIterable(t1, t2), true, t2._eval$1("Iterable.E"));
        C.JSArray_methods.sort$0(indices);
        for (t2 = indices.length, _i = 0; _i < indices.length; indices.length === t2 || (0, B.throwConcurrentModificationError)(indices), ++_i) {
          index = indices[_i];
          t3 = t1.$index(0, index);
          t3.toString;
          children.push(new B.DiagnosticableTreeNode(t3, _s17_ + index + " (kept alive but not laid out)", true, true, null, C.DiagnosticsTreeStyle_2));
        }
      }
      return children;
    }
  };
  A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin.prototype = {
    attach$1(owner) {
      var child, t1, t2;
      this.super$RenderObject$attach(owner);
      child = this.ContainerRenderObjectMixin__firstChild;
      for (t1 = type$.SliverMultiBoxAdaptorParentData; child != null;) {
        child.attach$1(owner);
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_nextSibling;
      }
    },
    detach$0() {
      var child, t1, t2;
      this.super$RenderObject$detach();
      child = this.ContainerRenderObjectMixin__firstChild;
      for (t1 = type$.SliverMultiBoxAdaptorParentData; child != null;) {
        child.detach$0();
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_nextSibling;
      }
    }
  };
  A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers.prototype = {};
  A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers_RenderSliverWithKeepAliveMixin.prototype = {};
  A._SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin.prototype = {
    detach$0() {
      this.super$ParentData$detach();
    }
  };
  A._SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin_KeepAliveParentDataMixin.prototype = {};
  A.RenderSliverEdgeInsetsPadding.prototype = {
    get$beforePadding() {
      var _this = this,
        t1 = type$.SliverConstraints;
      switch (B.applyGrowthDirectionToAxisDirection(t1._as(B.RenderObject.prototype.get$constraints.call(_this)).axisDirection, t1._as(B.RenderObject.prototype.get$constraints.call(_this)).growthDirection).index) {
        case 0:
          t1 = _this._resolvedPadding.bottom;
          break;
        case 1:
          t1 = _this._resolvedPadding.left;
          break;
        case 2:
          t1 = _this._resolvedPadding.top;
          break;
        case 3:
          t1 = _this._resolvedPadding.right;
          break;
        default:
          t1 = null;
      }
      return t1;
    },
    get$afterPadding() {
      var _this = this,
        t1 = type$.SliverConstraints;
      switch (B.applyGrowthDirectionToAxisDirection(t1._as(B.RenderObject.prototype.get$constraints.call(_this)).axisDirection, t1._as(B.RenderObject.prototype.get$constraints.call(_this)).growthDirection).index) {
        case 0:
          t1 = _this._resolvedPadding.top;
          break;
        case 1:
          t1 = _this._resolvedPadding.right;
          break;
        case 2:
          t1 = _this._resolvedPadding.bottom;
          break;
        case 3:
          t1 = _this._resolvedPadding.left;
          break;
        default:
          t1 = null;
      }
      return t1;
    },
    get$crossAxisPadding() {
      switch (B.axisDirectionToAxis(type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(this)).axisDirection).index) {
        case 0:
          var t1 = this._resolvedPadding;
          t1 = t1.get$_top() + t1.get$_bottom();
          break;
        case 1:
          t1 = this._resolvedPadding.get$horizontal();
          break;
        default:
          t1 = null;
      }
      return t1;
    },
    setupParentData$1(child) {
      if (!(child.parentData instanceof A.SliverPhysicalParentData))
        child.parentData = new A.SliverPhysicalParentData(C.Offset_0_0);
    },
    performLayout$0() {
      var beforePadding, t3, mainAxisPadding, crossAxisPadding, paintExtent, beforePaddingPaintExtent, overlap, t4, t5, t6, t7, t8, t9, t10, t11, childLayoutGeometry, scrollExtent, beforePaddingCacheExtent, afterPaddingCacheExtent, afterPaddingPaintExtent, mainAxisPaddingPaintExtent, _this = this, _null = null,
        t1 = type$.SliverConstraints,
        constraints = t1._as(B.RenderObject.prototype.get$constraints.call(_this)),
        paintOffset = new A.RenderSliverEdgeInsetsPadding_performLayout_paintOffset(_this, constraints),
        cacheOffset = new A.RenderSliverEdgeInsetsPadding_performLayout_cacheOffset(_this, constraints),
        t2 = _this._resolvedPadding;
      t2.toString;
      beforePadding = _this.get$beforePadding();
      _this.get$afterPadding();
      t3 = _this._resolvedPadding;
      t3.toString;
      mainAxisPadding = t3.along$1(B.axisDirectionToAxis(t1._as(B.RenderObject.prototype.get$constraints.call(_this)).axisDirection));
      crossAxisPadding = _this.get$crossAxisPadding();
      if (_this.RenderObjectWithChildMixin__child == null) {
        paintExtent = paintOffset.call$2$from$to(0, mainAxisPadding);
        _this._geometry = A.SliverGeometry$(cacheOffset.call$2$from$to(0, mainAxisPadding), false, _null, _null, mainAxisPadding, Math.min(paintExtent, constraints.remainingPaintExtent), 0, mainAxisPadding, _null);
        return;
      }
      beforePaddingPaintExtent = paintOffset.call$2$from$to(0, beforePadding);
      overlap = constraints.overlap;
      if (overlap > 0)
        overlap = Math.max(0, overlap - beforePaddingPaintExtent);
      t1 = _this.RenderObjectWithChildMixin__child;
      t1.toString;
      t3 = Math.max(0, constraints.scrollOffset - beforePadding);
      t4 = Math.min(0, constraints.cacheOrigin + beforePadding);
      t5 = constraints.remainingPaintExtent;
      t6 = paintOffset.call$2$from$to(0, beforePadding);
      t7 = constraints.remainingCacheExtent;
      t8 = cacheOffset.call$2$from$to(0, beforePadding);
      t9 = Math.max(0, constraints.crossAxisExtent - crossAxisPadding);
      t10 = constraints.axisDirection;
      t11 = constraints.growthDirection;
      t1.layout$2$parentUsesSize(new A.SliverConstraints(t10, t11, constraints.userScrollDirection, t3, beforePadding + constraints.precedingScrollExtent, overlap, t5 - t6, t9, constraints.crossAxisDirection, constraints.viewportMainAxisExtent, t4, t7 - t8), true);
      childLayoutGeometry = _this.RenderObjectWithChildMixin__child._geometry;
      t1 = childLayoutGeometry.scrollOffsetCorrection;
      if (t1 != null) {
        _this._geometry = A.SliverGeometry$(_null, false, _null, _null, 0, 0, 0, 0, t1);
        return;
      }
      scrollExtent = childLayoutGeometry.scrollExtent;
      beforePaddingCacheExtent = cacheOffset.call$2$from$to(0, beforePadding);
      t1 = beforePadding + scrollExtent;
      t3 = mainAxisPadding + scrollExtent;
      afterPaddingCacheExtent = cacheOffset.call$2$from$to(t1, t3);
      afterPaddingPaintExtent = paintOffset.call$2$from$to(t1, t3);
      mainAxisPaddingPaintExtent = beforePaddingPaintExtent + afterPaddingPaintExtent;
      t1 = childLayoutGeometry.paintExtent;
      t4 = childLayoutGeometry.layoutExtent;
      paintExtent = Math.min(beforePaddingPaintExtent + Math.max(t1, t4 + afterPaddingPaintExtent), t5);
      t5 = childLayoutGeometry.paintOrigin;
      t4 = Math.min(mainAxisPaddingPaintExtent + t4, paintExtent);
      t7 = Math.min(beforePaddingCacheExtent + afterPaddingCacheExtent + childLayoutGeometry.cacheExtent, t7);
      t6 = childLayoutGeometry.maxPaintExtent;
      t1 = Math.max(mainAxisPaddingPaintExtent + t1, beforePaddingPaintExtent + childLayoutGeometry.hitTestExtent);
      _this._geometry = A.SliverGeometry$(t7, childLayoutGeometry.hasVisualOverflow, t1, t4, mainAxisPadding + t6, paintExtent, t5, t3, _null);
      switch (B.applyGrowthDirectionToAxisDirection(t10, t11).index) {
        case 0:
          t1 = paintOffset.call$2$from$to(t2.bottom + scrollExtent, t2.get$_top() + t2.get$_bottom() + scrollExtent);
          break;
        case 3:
          t1 = paintOffset.call$2$from$to(t2.right + scrollExtent, t2.get$horizontal() + scrollExtent);
          break;
        case 1:
          t1 = paintOffset.call$2$from$to(0, t2.left);
          break;
        case 2:
          t1 = paintOffset.call$2$from$to(0, t2.top);
          break;
        default:
          t1 = _null;
      }
      t3 = _this.RenderObjectWithChildMixin__child.parentData;
      t3.toString;
      type$.SliverPhysicalParentData._as(t3);
      switch (B.axisDirectionToAxis(t10).index) {
        case 0:
          t1 = new B.Offset(t1, t2.top);
          break;
        case 1:
          t1 = new B.Offset(t2.left, t1);
          break;
        default:
          t1 = _null;
      }
      t3.paintOffset = t1;
    },
    hitTestChildren$3$crossAxisPosition$mainAxisPosition(result, crossAxisPosition, mainAxisPosition) {
      var t2, t3, t4, isHit, _this = this,
        t1 = _this.RenderObjectWithChildMixin__child;
      if (t1 != null && t1._geometry.hitTestExtent > 0) {
        t1 = t1.parentData;
        t1.toString;
        type$.SliverPhysicalParentData._as(t1);
        t2 = _this.calculatePaintOffset$3$from$to(type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(_this)), 0, _this.get$beforePadding());
        t3 = _this.RenderObjectWithChildMixin__child;
        t3.toString;
        t3 = _this.childCrossAxisPosition$1(t3);
        t1 = t1.paintOffset;
        t4 = _this.RenderObjectWithChildMixin__child.get$hitTest();
        result._localTransforms.push(new B._OffsetTransformPart(new B.Offset(-t1._dx, -t1._dy)));
        isHit = t4.call$3$crossAxisPosition$mainAxisPosition(result, crossAxisPosition - t3, mainAxisPosition - t2);
        result.popTransform$0();
        return isHit;
      }
      return false;
    },
    childCrossAxisPosition$1(child) {
      var t1;
      switch (B.axisDirectionToAxis(type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(this)).axisDirection).index) {
        case 0:
          t1 = this._resolvedPadding.top;
          break;
        case 1:
          t1 = this._resolvedPadding.left;
          break;
        default:
          t1 = null;
      }
      return t1;
    },
    childScrollOffset$1(child) {
      return this.get$beforePadding();
    },
    applyPaintTransform$2(child, transform) {
      var t1 = child.parentData;
      t1.toString;
      t1 = type$.SliverPhysicalParentData._as(t1).paintOffset;
      transform.translate$2(t1._dx, t1._dy);
    },
    paint$2(context, offset) {
      var t2,
        t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null && t1._geometry.visible) {
        t2 = t1.parentData;
        t2.toString;
        context.paintChild$2(t1, offset.$add(0, type$.SliverPhysicalParentData._as(t2).paintOffset));
      }
    }
  };
  A.RenderSliverPadding.prototype = {
    _sliver_padding$_resolve$0() {
      if (this._resolvedPadding != null)
        return;
      this._resolvedPadding = this._sliver_padding$_padding;
    },
    set$padding(value) {
      var _this = this;
      if (_this._sliver_padding$_padding.$eq(0, value))
        return;
      _this._sliver_padding$_padding = value;
      _this._resolvedPadding = null;
      _this.markNeedsLayout$0();
    },
    set$textDirection(value) {
      var _this = this;
      if (_this._sliver_padding$_textDirection === value)
        return;
      _this._sliver_padding$_textDirection = value;
      _this._resolvedPadding = null;
      _this.markNeedsLayout$0();
    },
    performLayout$0() {
      this._sliver_padding$_resolve$0();
      this.super$RenderSliverEdgeInsetsPadding$performLayout();
    }
  };
  A._RenderSliverEdgeInsetsPadding_RenderSliver_RenderObjectWithChildMixin.prototype = {
    attach$1(owner) {
      var t1;
      this.super$RenderObject$attach(owner);
      t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        t1.attach$1(owner);
    },
    detach$0() {
      this.super$RenderObject$detach();
      var t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        t1.detach$0();
    }
  };
  A.CacheExtentStyle.prototype = {
    _enumToString$0() {
      return "CacheExtentStyle." + this._name;
    }
  };
  A.RenderViewportBase.prototype = {
    describeSemanticsConfiguration$1(config) {
      this.super$RenderObject$describeSemanticsConfiguration(config);
      config.addTagForChildren$1(H.SemanticsTag_C6p);
    },
    visitChildrenForSemantics$1(visitor) {
      var t1 = this.get$childrenInPaintOrder();
      new B.WhereIterable(t1, new A.RenderViewportBase_visitChildrenForSemantics_closure(), B._arrayInstanceType(t1)._eval$1("WhereIterable<1>")).forEach$1(0, visitor);
    },
    set$axisDirection(value) {
      if (value === this._axisDirection)
        return;
      this._axisDirection = value;
      this.markNeedsLayout$0();
    },
    set$crossAxisDirection(value) {
      if (value === this._crossAxisDirection)
        return;
      this._crossAxisDirection = value;
      this.markNeedsLayout$0();
    },
    set$offset(value) {
      var _this = this,
        t1 = _this._viewport$_offset;
      if (value === t1)
        return;
      if (_this._object$_owner != null)
        t1.removeListener$1(_this.get$markNeedsLayout());
      _this._viewport$_offset = value;
      if (_this._object$_owner != null)
        value.addListener$1(_this.get$markNeedsLayout());
      _this.markNeedsLayout$0();
    },
    set$cacheExtent(value) {
      if (250 === this._cacheExtent)
        return;
      this._cacheExtent = 250;
      this.markNeedsLayout$0();
    },
    set$cacheExtentStyle(value) {
      if (value === this._cacheExtentStyle)
        return;
      this._cacheExtentStyle = value;
      this.markNeedsLayout$0();
    },
    set$clipBehavior(value) {
      var _this = this;
      if (value !== _this._viewport$_clipBehavior) {
        _this._viewport$_clipBehavior = value;
        _this.markNeedsPaint$0();
        _this.markNeedsSemanticsUpdate$0();
      }
    },
    attach$1(owner) {
      this.super$_RenderViewportBase_RenderBox_ContainerRenderObjectMixin$attach(owner);
      this._viewport$_offset.addListener$1(this.get$markNeedsLayout());
    },
    detach$0() {
      this._viewport$_offset.removeListener$1(this.get$markNeedsLayout());
      this.super$_RenderViewportBase_RenderBox_ContainerRenderObjectMixin$detach();
    },
    computeMinIntrinsicWidth$1(height) {
      return 0;
    },
    computeMaxIntrinsicWidth$1(height) {
      return 0;
    },
    computeMinIntrinsicHeight$1(width) {
      return 0;
    },
    computeMaxIntrinsicHeight$1(width) {
      return 0;
    },
    get$isRepaintBoundary() {
      return true;
    },
    layoutChildSequence$11$advance$cacheOrigin$child$crossAxisExtent$growthDirection$layoutOffset$mainAxisExtent$overlap$remainingCacheExtent$remainingPaintExtent$scrollOffset(advance, cacheOrigin, child, crossAxisExtent, growthDirection, layoutOffset, mainAxisExtent, overlap, remainingCacheExtent, remainingPaintExtent, scrollOffset) {
      var layoutOffset0, precedingScrollExtent, sliverScrollOffset, correctedCacheOrigin, cacheExtentCorrection, childLayoutGeometry, t1, effectiveLayoutOffset, _this = this,
        adjustedUserScrollDirection = A.applyGrowthDirectionToScrollDirection(_this._viewport$_offset._userScrollDirection, growthDirection),
        maxPaintOffset = layoutOffset + overlap;
      for (layoutOffset0 = layoutOffset, precedingScrollExtent = 0; child != null;) {
        sliverScrollOffset = scrollOffset <= 0 ? 0 : scrollOffset;
        correctedCacheOrigin = Math.max(cacheOrigin, -sliverScrollOffset);
        cacheExtentCorrection = cacheOrigin - correctedCacheOrigin;
        child.layout$2$parentUsesSize(new A.SliverConstraints(_this._axisDirection, growthDirection, adjustedUserScrollDirection, sliverScrollOffset, precedingScrollExtent, maxPaintOffset - layoutOffset0, Math.max(0, remainingPaintExtent - layoutOffset0 + layoutOffset), crossAxisExtent, _this._crossAxisDirection, mainAxisExtent, correctedCacheOrigin, Math.max(0, remainingCacheExtent + cacheExtentCorrection)), true);
        childLayoutGeometry = child._geometry;
        t1 = childLayoutGeometry.scrollOffsetCorrection;
        if (t1 != null)
          return t1;
        effectiveLayoutOffset = layoutOffset0 + childLayoutGeometry.paintOrigin;
        if (childLayoutGeometry.visible || scrollOffset > 0)
          _this.updateChildLayoutOffset$3(child, effectiveLayoutOffset, growthDirection);
        else
          _this.updateChildLayoutOffset$3(child, -scrollOffset + layoutOffset, growthDirection);
        maxPaintOffset = Math.max(effectiveLayoutOffset + childLayoutGeometry.paintExtent, maxPaintOffset);
        t1 = childLayoutGeometry.scrollExtent;
        scrollOffset -= t1;
        precedingScrollExtent += t1;
        layoutOffset0 += childLayoutGeometry.layoutExtent;
        t1 = childLayoutGeometry.cacheExtent;
        if (t1 !== 0) {
          remainingCacheExtent -= t1 - cacheExtentCorrection;
          cacheOrigin = Math.min(correctedCacheOrigin + t1, 0);
        }
        _this.updateOutOfBandData$2(growthDirection, childLayoutGeometry);
        child = advance.call$1(child);
      }
      return 0;
    },
    describeApproximatePaintClip$1(child) {
      var t1, right, bottom, overlapCorrection, left, $top;
      switch (this._viewport$_clipBehavior.index) {
        case 0:
          return null;
        case 1:
        case 2:
        case 3:
          break;
      }
      t1 = this.get$size();
      right = 0 + t1._dx;
      bottom = 0 + t1._dy;
      t1 = type$.SliverConstraints;
      if (t1._as(B.RenderObject.prototype.get$constraints.call(child)).overlap === 0 || !isFinite(t1._as(B.RenderObject.prototype.get$constraints.call(child)).viewportMainAxisExtent))
        return new B.Rect(0, 0, right, bottom);
      overlapCorrection = t1._as(B.RenderObject.prototype.get$constraints.call(child)).viewportMainAxisExtent - t1._as(B.RenderObject.prototype.get$constraints.call(child)).remainingPaintExtent + t1._as(B.RenderObject.prototype.get$constraints.call(child)).overlap;
      left = 0;
      $top = 0;
      switch (B.applyGrowthDirectionToAxisDirection(this._axisDirection, t1._as(B.RenderObject.prototype.get$constraints.call(child)).growthDirection).index) {
        case 2:
          $top = 0 + overlapCorrection;
          break;
        case 0:
          bottom -= overlapCorrection;
          break;
        case 1:
          left = 0 + overlapCorrection;
          break;
        case 3:
          right -= overlapCorrection;
          break;
      }
      return new B.Rect(left, $top, right, bottom);
    },
    describeSemanticsClip$1(child) {
      var t1, t2, t3, t4, _this = this;
      if (_this._calculatedCacheExtent == null) {
        t1 = _this.get$size();
        return new B.Rect(0, 0, 0 + t1._dx, 0 + t1._dy);
      }
      switch (B.axisDirectionToAxis(_this._axisDirection).index) {
        case 1:
          _this.get$size();
          _this.get$size();
          t1 = _this._calculatedCacheExtent;
          t1.toString;
          t2 = _this.get$size();
          t3 = _this.get$size();
          t4 = _this._calculatedCacheExtent;
          t4.toString;
          return new B.Rect(0, 0 - t1, 0 + t2._dx, 0 + t3._dy + t4);
        case 0:
          _this.get$size();
          t1 = _this._calculatedCacheExtent;
          t1.toString;
          _this.get$size();
          t2 = _this.get$size();
          t3 = _this._calculatedCacheExtent;
          t3.toString;
          return new B.Rect(0 - t1, 0, 0 + t2._dx + t3, 0 + _this.get$size()._dy);
      }
    },
    paint$2(context, offset) {
      var t1, t2, t3, _this = this;
      if (_this.ContainerRenderObjectMixin__firstChild == null)
        return;
      t1 = _this.get$hasVisualOverflow() && _this._viewport$_clipBehavior !== C.Clip_0;
      t2 = _this._viewport$_clipRectLayer;
      if (t1) {
        t1 = _this.__RenderObject__needsCompositing_A;
        t1 === $ && B.throwUnnamedLateFieldNI();
        t3 = _this.get$size();
        t2.set$layer(context.pushClipRect$6$clipBehavior$oldLayer(t1, offset, new B.Rect(0, 0, 0 + t3._dx, 0 + t3._dy), _this.get$_viewport$_paintContents(), _this._viewport$_clipBehavior, t2._layer));
      } else {
        t2.set$layer(null);
        _this._viewport$_paintContents$2(context, offset);
      }
    },
    dispose$0() {
      this._viewport$_clipRectLayer.set$layer(null);
      this.super$RenderObject$dispose();
    },
    _viewport$_paintContents$2(context, offset) {
      var t1, t2, t3, t4, _i, child, t5;
      for (t1 = this.get$childrenInPaintOrder(), t2 = t1.length, t3 = offset._dx, t4 = offset._dy, _i = 0; _i < t1.length; t1.length === t2 || (0, B.throwConcurrentModificationError)(t1), ++_i) {
        child = t1[_i];
        if (child._geometry.visible) {
          t5 = this.paintOffsetOf$1(child);
          context.paintChild$2(child, new B.Offset(t3 + t5._dx, t4 + t5._dy));
        }
      }
    },
    hitTestChildren$2$position(result, position) {
      var _0_1, _0_2, sliverResult, t2, _i, child, transform, _this = this, _box_0 = {},
        t1 = _box_0.crossAxisPosition = _box_0.mainAxisPosition = null;
      switch (B.axisDirectionToAxis(_this._axisDirection).index) {
        case 1:
          t1 = new B._Record_2(position._dy, position._dx);
          break;
        case 0:
          t1 = new B._Record_2(position._dx, position._dy);
          break;
      }
      _0_1 = t1._0;
      _box_0.mainAxisPosition = _0_1;
      _0_2 = t1._1;
      _box_0.crossAxisPosition = _0_2;
      sliverResult = new A.SliverHitTestResult(result._path, result._transforms, result._localTransforms);
      for (t1 = _this.get$childrenInHitTestOrder(), t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, B.throwConcurrentModificationError)(t1), ++_i) {
        child = t1[_i];
        if (!child._geometry.visible)
          continue;
        transform = new B.Matrix40(new Float64Array(16));
        transform.setIdentity$0();
        _this.applyPaintTransform$2(child, transform);
        if (result.addWithOutOfBandPosition$2$hitTest$paintTransform(new A.RenderViewportBase_hitTestChildren_closure(_box_0, _this, child, sliverResult), transform))
          return true;
      }
      return false;
    },
    getOffsetToReveal$4$axis$rect(target, alignment, axis, rect) {
      var onlySlivers, pivot, child, leadingScrollOffset, t1, t2, growthDirection, rectLocal, pivotExtent, targetRect, extentOfPinnedSlivers, targetOffset, offsetDifference, _this = this, _null = null;
      axis = B.axisDirectionToAxis(_this._axisDirection);
      onlySlivers = target instanceof A.RenderSliver;
      for (pivot = _null, child = target, leadingScrollOffset = 0; child.get$parent() !== _this; child = t1) {
        t1 = child.get$parent();
        t1.toString;
        if (child instanceof B.RenderBox)
          pivot = child;
        if (t1 instanceof A.RenderSliver) {
          t2 = t1.childScrollOffset$1(child);
          t2.toString;
          leadingScrollOffset += t2;
        } else {
          leadingScrollOffset = 0;
          onlySlivers = false;
        }
      }
      if (pivot != null) {
        t1 = pivot.get$parent();
        t1.toString;
        type$.RenderSliver._as(t1);
        growthDirection = type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(t1)).growthDirection;
        switch (axis.index) {
          case 0:
            t1 = pivot.get$size()._dx;
            break;
          case 1:
            t1 = pivot.get$size()._dy;
            break;
          default:
            t1 = _null;
        }
        if (rect == null)
          rect = target.get$paintBounds();
        rectLocal = B.MatrixUtils_transformRect(target.getTransformTo$1(pivot), rect);
        pivotExtent = t1;
      } else {
        if (onlySlivers) {
          type$.RenderSliver._as(target);
          t1 = type$.SliverConstraints;
          growthDirection = t1._as(B.RenderObject.prototype.get$constraints.call(target)).growthDirection;
          pivotExtent = target._geometry.scrollExtent;
          if (rect == null)
            switch (axis.index) {
              case 0:
                rect = new B.Rect(0, 0, 0 + pivotExtent, 0 + t1._as(B.RenderObject.prototype.get$constraints.call(target)).crossAxisExtent);
                break;
              case 1:
                rect = new B.Rect(0, 0, 0 + t1._as(B.RenderObject.prototype.get$constraints.call(target)).crossAxisExtent, 0 + target._geometry.scrollExtent);
                break;
            }
        } else {
          t1 = _this._viewport$_offset._pixels;
          t1.toString;
          rect.toString;
          return new F.RevealedOffset(t1, rect);
        }
        rectLocal = rect;
      }
      type$.RenderSliver._as(child);
      switch (B.applyGrowthDirectionToAxisDirection(_this._axisDirection, growthDirection).index) {
        case 0:
          t1 = pivotExtent - rectLocal.bottom;
          break;
        case 3:
          t1 = pivotExtent - rectLocal.right;
          break;
        case 1:
          t1 = rectLocal.left;
          break;
        case 2:
          t1 = rectLocal.top;
          break;
        default:
          t1 = _null;
      }
      child._geometry.toString;
      leadingScrollOffset = _this.scrollOffsetOf$2(child, leadingScrollOffset + t1);
      targetRect = B.MatrixUtils_transformRect(target.getTransformTo$1(_this), rect);
      extentOfPinnedSlivers = _this.maxScrollObstructionExtentBefore$1(child);
      switch (type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(child)).growthDirection.index) {
        case 0:
          leadingScrollOffset -= extentOfPinnedSlivers;
          break;
        case 1:
          switch (axis.index) {
            case 1:
              t1 = targetRect.bottom - targetRect.top;
              break;
            case 0:
              t1 = targetRect.right - targetRect.left;
              break;
            default:
              t1 = _null;
          }
          leadingScrollOffset -= t1;
          break;
      }
      switch (axis.index) {
        case 0:
          t1 = _this.get$size()._dx - extentOfPinnedSlivers - (rectLocal.right - rectLocal.left);
          break;
        case 1:
          t1 = _this.get$size()._dy - extentOfPinnedSlivers - (rectLocal.bottom - rectLocal.top);
          break;
        default:
          t1 = _null;
      }
      targetOffset = leadingScrollOffset - t1 * alignment;
      t1 = _this._viewport$_offset._pixels;
      t1.toString;
      offsetDifference = t1 - targetOffset;
      switch (_this._axisDirection.index) {
        case 0:
          t1 = targetRect.translate$2(0, -offsetDifference);
          break;
        case 2:
          t1 = targetRect.translate$2(0, offsetDifference);
          break;
        case 3:
          t1 = targetRect.translate$2(-offsetDifference, 0);
          break;
        case 1:
          t1 = targetRect.translate$2(offsetDifference, 0);
          break;
        default:
          t1 = _null;
      }
      return new F.RevealedOffset(targetOffset, t1);
    },
    getOffsetToReveal$3$rect(target, alignment, rect) {
      return this.getOffsetToReveal$4$axis$rect(target, alignment, null, rect);
    },
    computeAbsolutePaintOffset$3(child, layoutOffset, growthDirection) {
      var t1;
      switch (B.applyGrowthDirectionToAxisDirection(this._axisDirection, growthDirection).index) {
        case 0:
          t1 = new B.Offset(0, this.get$size()._dy - layoutOffset - child._geometry.paintExtent);
          break;
        case 3:
          t1 = new B.Offset(this.get$size()._dx - layoutOffset - child._geometry.paintExtent, 0);
          break;
        case 1:
          t1 = new B.Offset(layoutOffset, 0);
          break;
        case 2:
          t1 = new B.Offset(0, layoutOffset);
          break;
        default:
          t1 = null;
      }
      return t1;
    },
    debugDescribeChildren$0() {
      var count, t1, t2, _this = this,
        children = B._setArrayType([], type$.JSArray_DiagnosticsNode),
        child = _this.ContainerRenderObjectMixin__firstChild;
      if (child == null)
        return children;
      count = _this.get$indexOfFirstChild();
      for (t1 = B._instanceType(_this)._eval$1("ContainerRenderObjectMixin.1"); true;) {
        child.toString;
        children.push(new B.DiagnosticableTreeNode(child, _this.labelForChild$1(count), true, true, null, null));
        if (child === _this.ContainerRenderObjectMixin__lastChild)
          break;
        ++count;
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_nextSibling;
      }
      return children;
    },
    showOnScreen$4$curve$descendant$duration$rect(curve, descendant, duration, rect) {
      this.super$RenderObject$showOnScreen(curve, null, duration, E.RenderViewportBase_showInViewport(curve, descendant, duration, this._viewport$_offset, rect, this));
    },
    showOnScreen$0() {
      return this.showOnScreen$4$curve$descendant$duration$rect(C.Cubic_glB, null, C.Duration_0, null);
    },
    showOnScreen$1$rect(rect) {
      return this.showOnScreen$4$curve$descendant$duration$rect(C.Cubic_glB, null, C.Duration_0, rect);
    },
    showOnScreen$3$curve$duration$rect(curve, duration, rect) {
      return this.showOnScreen$4$curve$descendant$duration$rect(curve, null, duration, rect);
    },
    showOnScreen$2$descendant$rect(descendant, rect) {
      return this.showOnScreen$4$curve$descendant$duration$rect(C.Cubic_glB, descendant, C.Duration_0, rect);
    },
    $isRenderAbstractViewport: 1
  };
  A.RenderViewport.prototype = {
    setupParentData$1(child) {
      if (!(child.parentData instanceof A.SliverPhysicalContainerParentData))
        child.parentData = new A.SliverPhysicalContainerParentData(null, null, C.Offset_0_0);
    },
    set$anchor(value) {
      if (value === this._anchor)
        return;
      this._anchor = value;
      this.markNeedsLayout$0();
    },
    set$center(value) {
      if (value == this._center)
        return;
      this._center = value;
      this.markNeedsLayout$0();
    },
    get$sizedByParent() {
      return true;
    },
    computeDryLayout$1(constraints) {
      return new B.Size(B.clampDouble(1 / 0, constraints.minWidth, constraints.maxWidth), B.clampDouble(1 / 0, constraints.minHeight, constraints.maxHeight));
    },
    performLayout$0() {
      var t1, _0_1, crossAxisExtent, _0_2, mainAxisExtent, maxLayoutCycles, count, correction, t2, t3, t4, _this = this;
      switch (B.axisDirectionToAxis(_this._axisDirection).index) {
        case 1:
          _this._viewport$_offset.applyViewportDimension$1(_this.get$size()._dy);
          break;
        case 0:
          _this._viewport$_offset.applyViewportDimension$1(_this.get$size()._dx);
          break;
      }
      if (_this._center == null) {
        _this.__RenderViewport__maxScrollExtent_A = _this.__RenderViewport__minScrollExtent_A = 0;
        _this._viewport$_hasVisualOverflow = false;
        _this._viewport$_offset.applyContentDimensions$2(0, 0);
        return;
      }
      switch (B.axisDirectionToAxis(_this._axisDirection).index) {
        case 1:
          t1 = new B._Record_2(_this.get$size()._dy, _this.get$size()._dx);
          break;
        case 0:
          t1 = new B._Record_2(_this.get$size()._dx, _this.get$size()._dy);
          break;
        default:
          t1 = null;
      }
      _0_1 = t1._0;
      crossAxisExtent = null;
      _0_2 = t1._1;
      crossAxisExtent = _0_2;
      mainAxisExtent = _0_1;
      _this._center.toString;
      maxLayoutCycles = 10 * _this.ContainerRenderObjectMixin__childCount;
      count = 0;
      do {
        t1 = _this._viewport$_offset._pixels;
        t1.toString;
        correction = _this._attemptLayout$3(mainAxisExtent, crossAxisExtent, t1 + 0);
        if (correction !== 0)
          _this._viewport$_offset.correctBy$1(correction);
        else {
          t1 = _this._viewport$_offset;
          t2 = _this.__RenderViewport__minScrollExtent_A;
          t2 === $ && B.throwUnnamedLateFieldNI();
          t3 = _this._anchor;
          t2 = Math.min(0, t2 + mainAxisExtent * t3);
          t4 = _this.__RenderViewport__maxScrollExtent_A;
          t4 === $ && B.throwUnnamedLateFieldNI();
          if (t1.applyContentDimensions$2(t2, Math.max(0, t4 - mainAxisExtent * (1 - t3))))
            break;
        }
        ++count;
      } while (count < maxLayoutCycles);
    },
    _attemptLayout$3(mainAxisExtent, crossAxisExtent, correctedOffset) {
      var centerOffset, reverseDirectionRemainingPaintExtent, t1, forwardDirectionRemainingPaintExtent, t2, fullCacheExtent, centerCacheOffset, reverseDirectionRemainingCacheExtent, forwardDirectionRemainingCacheExtent, t3, leadingNegativeChild, t4, result, t5, _this = this;
      _this.__RenderViewport__maxScrollExtent_A = _this.__RenderViewport__minScrollExtent_A = 0;
      _this._viewport$_hasVisualOverflow = false;
      centerOffset = mainAxisExtent * _this._anchor - correctedOffset;
      reverseDirectionRemainingPaintExtent = B.clampDouble(centerOffset, 0, mainAxisExtent);
      t1 = mainAxisExtent - centerOffset;
      forwardDirectionRemainingPaintExtent = B.clampDouble(t1, 0, mainAxisExtent);
      switch (_this._cacheExtentStyle.index) {
        case 0:
          t2 = _this._cacheExtent;
          break;
        case 1:
          t2 = mainAxisExtent * _this._cacheExtent;
          break;
        default:
          t2 = null;
      }
      _this._calculatedCacheExtent = t2;
      t2.toString;
      fullCacheExtent = mainAxisExtent + 2 * t2;
      centerCacheOffset = centerOffset + t2;
      reverseDirectionRemainingCacheExtent = B.clampDouble(centerCacheOffset, 0, fullCacheExtent);
      forwardDirectionRemainingCacheExtent = B.clampDouble(fullCacheExtent - centerCacheOffset, 0, fullCacheExtent);
      t3 = _this._center.parentData;
      t3.toString;
      leadingNegativeChild = B._instanceType(_this)._eval$1("ContainerRenderObjectMixin.1")._as(t3).ContainerParentDataMixin_previousSibling;
      t3 = leadingNegativeChild == null;
      if (!t3) {
        t4 = Math.max(mainAxisExtent, centerOffset);
        result = _this.layoutChildSequence$11$advance$cacheOrigin$child$crossAxisExtent$growthDirection$layoutOffset$mainAxisExtent$overlap$remainingCacheExtent$remainingPaintExtent$scrollOffset(_this.get$childBefore(), B.clampDouble(t1, -t2, 0), leadingNegativeChild, crossAxisExtent, C.GrowthDirection_1, forwardDirectionRemainingPaintExtent, mainAxisExtent, 0, reverseDirectionRemainingCacheExtent, reverseDirectionRemainingPaintExtent, t4 - mainAxisExtent);
        if (result !== 0)
          return -result;
      }
      t1 = _this._center;
      t2 = -centerOffset;
      t4 = Math.max(0, t2);
      t2 = t3 ? Math.min(0, t2) : 0;
      t3 = centerOffset >= mainAxisExtent ? centerOffset : reverseDirectionRemainingPaintExtent;
      t5 = _this._calculatedCacheExtent;
      t5.toString;
      return _this.layoutChildSequence$11$advance$cacheOrigin$child$crossAxisExtent$growthDirection$layoutOffset$mainAxisExtent$overlap$remainingCacheExtent$remainingPaintExtent$scrollOffset(_this.get$childAfter(), B.clampDouble(centerOffset, -t5, 0), t1, crossAxisExtent, C.GrowthDirection_0, t3, mainAxisExtent, t2, forwardDirectionRemainingCacheExtent, forwardDirectionRemainingPaintExtent, t4);
    },
    get$hasVisualOverflow() {
      return this._viewport$_hasVisualOverflow;
    },
    updateOutOfBandData$2(growthDirection, childLayoutGeometry) {
      var t1, _this = this;
      switch (growthDirection.index) {
        case 0:
          t1 = _this.__RenderViewport__maxScrollExtent_A;
          t1 === $ && B.throwUnnamedLateFieldNI();
          _this.__RenderViewport__maxScrollExtent_A = t1 + childLayoutGeometry.scrollExtent;
          break;
        case 1:
          t1 = _this.__RenderViewport__minScrollExtent_A;
          t1 === $ && B.throwUnnamedLateFieldNI();
          _this.__RenderViewport__minScrollExtent_A = t1 - childLayoutGeometry.scrollExtent;
          break;
      }
      if (childLayoutGeometry.hasVisualOverflow)
        _this._viewport$_hasVisualOverflow = true;
    },
    updateChildLayoutOffset$3(child, layoutOffset, growthDirection) {
      var t1 = child.parentData;
      t1.toString;
      type$.SliverPhysicalParentData._as(t1).paintOffset = this.computeAbsolutePaintOffset$3(child, layoutOffset, growthDirection);
    },
    paintOffsetOf$1(child) {
      var t1 = child.parentData;
      t1.toString;
      return type$.SliverPhysicalParentData._as(t1).paintOffset;
    },
    scrollOffsetOf$2(child, scrollOffsetWithinChild) {
      var current, t1, scrollOffsetToChild, t2, _this = this;
      switch (type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(child)).growthDirection.index) {
        case 0:
          current = _this._center;
          for (t1 = B._instanceType(_this)._eval$1("ContainerRenderObjectMixin.1"), scrollOffsetToChild = 0; current !== child;) {
            scrollOffsetToChild += current._geometry.scrollExtent;
            t2 = current.parentData;
            t2.toString;
            current = t1._as(t2).ContainerParentDataMixin_nextSibling;
          }
          return scrollOffsetToChild + scrollOffsetWithinChild;
        case 1:
          t1 = _this._center.parentData;
          t1.toString;
          t2 = B._instanceType(_this)._eval$1("ContainerRenderObjectMixin.1");
          current = t2._as(t1).ContainerParentDataMixin_previousSibling;
          for (scrollOffsetToChild = 0; current !== child;) {
            scrollOffsetToChild -= current._geometry.scrollExtent;
            t1 = current.parentData;
            t1.toString;
            current = t2._as(t1).ContainerParentDataMixin_previousSibling;
          }
          return scrollOffsetToChild - scrollOffsetWithinChild;
      }
    },
    maxScrollObstructionExtentBefore$1(child) {
      var current, t1, t2, _this = this;
      switch (type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(child)).growthDirection.index) {
        case 0:
          current = _this._center;
          for (t1 = B._instanceType(_this)._eval$1("ContainerRenderObjectMixin.1"); current !== child;) {
            current._geometry.toString;
            t2 = current.parentData;
            t2.toString;
            current = t1._as(t2).ContainerParentDataMixin_nextSibling;
          }
          return 0;
        case 1:
          t1 = _this._center.parentData;
          t1.toString;
          t2 = B._instanceType(_this)._eval$1("ContainerRenderObjectMixin.1");
          current = t2._as(t1).ContainerParentDataMixin_previousSibling;
          for (; current !== child;) {
            current._geometry.toString;
            t1 = current.parentData;
            t1.toString;
            current = t2._as(t1).ContainerParentDataMixin_previousSibling;
          }
          return 0;
      }
    },
    applyPaintTransform$2(child, transform) {
      var t1 = child.parentData;
      t1.toString;
      t1 = type$.SliverPhysicalParentData._as(t1).paintOffset;
      transform.translate$2(t1._dx, t1._dy);
    },
    computeChildMainAxisPosition$2(child, parentMainAxisPosition) {
      var paintOffset,
        t1 = child.parentData;
      t1.toString;
      paintOffset = type$.SliverPhysicalParentData._as(t1).paintOffset;
      t1 = type$.SliverConstraints;
      switch (B.applyGrowthDirectionToAxisDirection(t1._as(B.RenderObject.prototype.get$constraints.call(child)).axisDirection, t1._as(B.RenderObject.prototype.get$constraints.call(child)).growthDirection).index) {
        case 2:
          t1 = parentMainAxisPosition - paintOffset._dy;
          break;
        case 1:
          t1 = parentMainAxisPosition - paintOffset._dx;
          break;
        case 0:
          t1 = child._geometry.paintExtent - (parentMainAxisPosition - paintOffset._dy);
          break;
        case 3:
          t1 = child._geometry.paintExtent - (parentMainAxisPosition - paintOffset._dx);
          break;
        default:
          t1 = null;
      }
      return t1;
    },
    get$indexOfFirstChild() {
      var t1, t2, count, t3,
        child = this._center;
      for (t1 = this.ContainerRenderObjectMixin__firstChild, t2 = B._instanceType(this)._eval$1("ContainerRenderObjectMixin.1"), count = 0; child != t1;) {
        --count;
        t3 = child.parentData;
        t3.toString;
        child = t2._as(t3).ContainerParentDataMixin_previousSibling;
      }
      return count;
    },
    labelForChild$1(index) {
      if (index === 0)
        return "center child";
      return "child " + index;
    },
    get$childrenInPaintOrder() {
      var t1, t2, _this = this,
        children = B._setArrayType([], type$.JSArray_RenderSliver),
        child = _this.ContainerRenderObjectMixin__firstChild;
      if (child == null)
        return children;
      for (t1 = B._instanceType(_this)._eval$1("ContainerRenderObjectMixin.1"); child != _this._center;) {
        child.toString;
        children.push(child);
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_nextSibling;
      }
      child = _this.ContainerRenderObjectMixin__lastChild;
      for (; true;) {
        child.toString;
        children.push(child);
        if (child === _this._center)
          return children;
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_previousSibling;
      }
    },
    get$childrenInHitTestOrder() {
      var child, t1, t2, _this = this,
        children = B._setArrayType([], type$.JSArray_RenderSliver);
      if (_this.ContainerRenderObjectMixin__firstChild == null)
        return children;
      child = _this._center;
      for (t1 = B._instanceType(_this)._eval$1("ContainerRenderObjectMixin.1"); child != null;) {
        children.push(child);
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_nextSibling;
      }
      t2 = _this._center.parentData;
      t2.toString;
      child = t1._as(t2).ContainerParentDataMixin_previousSibling;
      for (; child != null;) {
        children.push(child);
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_previousSibling;
      }
      return children;
    }
  };
  A._RenderViewportBase_RenderBox_ContainerRenderObjectMixin.prototype = {
    attach$1(owner) {
      var child, t1, t2;
      this.super$RenderObject$attach(owner);
      child = this.ContainerRenderObjectMixin__firstChild;
      for (t1 = B._instanceType(this)._eval$1("_RenderViewportBase_RenderBox_ContainerRenderObjectMixin.0"); child != null;) {
        child.attach$1(owner);
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_nextSibling;
      }
    },
    detach$0() {
      var child, t1, t2;
      this.super$RenderObject$detach();
      child = this.ContainerRenderObjectMixin__firstChild;
      for (t1 = B._instanceType(this)._eval$1("_RenderViewportBase_RenderBox_ContainerRenderObjectMixin.0"); child != null;) {
        child.detach$0();
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_nextSibling;
      }
    }
  };
  A.AutomaticKeepAlive.prototype = {
    createState$0() {
      return new A._AutomaticKeepAliveState();
    }
  };
  A._AutomaticKeepAliveState.prototype = {
    initState$0() {
      this.super$State$initState();
      this._updateChild$0();
    },
    didUpdateWidget$1(oldWidget) {
      this.super$State$didUpdateWidget(oldWidget);
      this._updateChild$0();
    },
    _updateChild$0() {
      this.___AutomaticKeepAliveState__child_A = new B.NotificationListener(this.get$_addClient(), this._widget.child, null, type$.NotificationListener_KeepAliveNotification);
    },
    dispose$0() {
      var t2, t3,
        t1 = this._automatic_keep_alive$_handles;
      if (t1 != null)
        for (t1 = new B.LinkedHashMapKeyIterator(t1, t1._modifications, t1._first); t1.moveNext$0();) {
          t2 = t1.__js_helper$_current;
          t3 = this._automatic_keep_alive$_handles.$index(0, t2);
          t3.toString;
          t2.removeListener$1(t3);
        }
      this.super$State$dispose();
    },
    _addClient$1(notification) {
      var childElement, _this = this,
        handle = notification.handle,
        t1 = _this._automatic_keep_alive$_handles;
      if (t1 == null)
        t1 = _this._automatic_keep_alive$_handles = B.LinkedHashMap_LinkedHashMap$_empty(type$.Listenable, type$.void_Function);
      t1.$indexSet(0, handle, _this._createCallback$1(handle));
      t1 = _this._automatic_keep_alive$_handles.$index(0, handle);
      t1.toString;
      handle.addListener$1(t1);
      if (!_this._keepingAlive) {
        _this._keepingAlive = true;
        childElement = _this._getChildElement$0();
        if (childElement != null)
          _this._updateParentDataOfChild$1(childElement);
        else
          $.SchedulerBinding__instance.SchedulerBinding__postFrameCallbacks.push(new A._AutomaticKeepAliveState__addClient_closure(_this));
      }
      return false;
    },
    _getChildElement$0() {
      var t1 = {},
        t2 = this._framework$_element;
      t2.toString;
      t1.childElement = null;
      t2.visitChildren$1(new A._AutomaticKeepAliveState__getChildElement_closure(t1));
      return type$.nullable_ParentDataElement_KeepAliveParentDataMixin._as(t1.childElement);
    },
    _updateParentDataOfChild$1(childElement) {
      var t1, t2;
      this._framework$_element.toString;
      t1 = this._keepingAlive;
      t2 = this.___AutomaticKeepAliveState__child_A;
      t2 === $ && B.throwUnnamedLateFieldNI();
      childElement._applyParentData$1(type$.ParentDataWidget_KeepAliveParentDataMixin._as(A.KeepAlive$(t2, t1)));
    },
    _createCallback$1(handle) {
      var callback = B._Cell$named("callback"),
        t1 = new A._AutomaticKeepAliveState__createCallback_closure(this, handle, callback);
      callback.set$finalLocalValue(t1);
      return t1;
    },
    build$1(context) {
      var t1 = this._keepingAlive,
        t2 = this.___AutomaticKeepAliveState__child_A;
      t2 === $ && B.throwUnnamedLateFieldNI();
      return new A.KeepAlive(t1, t2, null);
    }
  };
  A.SliverPadding.prototype = {
    createRenderObject$1(context) {
      var t1 = new A.RenderSliverPadding(this.padding, context.dependOnInheritedWidgetOfExactType$1$0(type$.Directionality).textDirection, null, B.LayerHandle$());
      t1.RenderObject$0();
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2(context, renderObject) {
      renderObject.set$padding(this.padding);
      renderObject.set$textDirection(context.dependOnInheritedWidgetOfExactType$1$0(type$.Directionality).textDirection);
    }
  };
  A.IndexedSemantics.prototype = {
    createRenderObject$1(context) {
      var t1 = new A.RenderIndexedSemantics(this.index, null, new B._LayoutCacheStorage(), B.LayerHandle$());
      t1.RenderObject$0();
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2(context, renderObject) {
      renderObject.set$index(this.index);
    }
  };
  A.SliverChildDelegate.prototype = {
    toString$0(_) {
      var description = B._setArrayType([], type$.JSArray_String);
      this.debugFillDescription$1(description);
      return "<optimized out>#" + B.shortHash(this) + "(" + C.JSArray_methods.join$1(description, ", ") + ")";
    },
    debugFillDescription$1(description) {
      var children, e, exception;
      try {
        children = this.childCount;
        if (children != null)
          description.push("estimated child count: " + B.S(children));
      } catch (exception) {
        e = B.unwrapException(exception);
        description.push("estimated child count: EXCEPTION (" + J.get$runtimeType$(e).toString$0(0) + ")");
      }
    }
  };
  A._SaltedValueKey.prototype = {};
  A.SliverChildBuilderDelegate.prototype = {
    findIndexByKey$1(key) {
      return null;
    },
    build$2(context, index) {
      var child, exception, stackTrace, t1, exception0, details, key, semanticIndex, _null = null;
      if (index >= 0)
        t1 = index >= this.childCount;
      else
        t1 = true;
      if (t1)
        return _null;
      child = null;
      try {
        child = this.builder.call$2(context, index);
      } catch (exception0) {
        exception = B.unwrapException(exception0);
        stackTrace = B.getTraceFromException(exception0);
        details = new B.FlutterErrorDetails(exception, stackTrace, "widgets library", B.ErrorDescription$("building"), _null, false);
        B.FlutterError_reportError(details);
        child = B.ErrorWidget__defaultErrorWidgetBuilder(details);
      }
      if (child == null)
        return _null;
      if (child.key != null) {
        t1 = child.key;
        t1.toString;
        key = new A._SaltedValueKey(t1);
      } else
        key = _null;
      t1 = child;
      child = new B.RepaintBoundary(t1, _null);
      semanticIndex = A._kDefaultSemanticIndexCallback(child, index);
      if (semanticIndex != null)
        child = new A.IndexedSemantics(semanticIndex, child, _null);
      t1 = child;
      child = new A.AutomaticKeepAlive(new A._SelectionKeepAlive(t1, _null), _null);
      return new B.KeyedSubtree(child, key);
    }
  };
  A._SelectionKeepAlive.prototype = {
    createState$0() {
      return new A._SelectionKeepAliveState(null);
    }
  };
  A._SelectionKeepAliveState.prototype = {
    get$wantKeepAlive() {
      return this._wantKeepAlive;
    },
    listensTo$1(selectable) {
      return new A._SelectionKeepAliveState_listensTo_closure(this, selectable);
    },
    _updateSelectablesWithSelections$2$add(selectable, add) {
      var t1, _this = this;
      if (add) {
        t1 = _this._selectablesWithSelections;
        (t1 == null ? _this._selectablesWithSelections = B.LinkedHashSet_LinkedHashSet$_empty(type$.Selectable) : t1).add$1(0, selectable);
      } else {
        t1 = _this._selectablesWithSelections;
        if (t1 != null)
          t1.remove$1(0, selectable);
      }
      t1 = _this._selectablesWithSelections;
      t1 = t1 == null ? null : t1._collection$_length !== 0;
      t1 = t1 === true;
      if (_this._wantKeepAlive !== t1) {
        _this._wantKeepAlive = t1;
        _this.updateKeepAlive$0();
      }
    },
    didChangeDependencies$0() {
      var t1, newRegistrar, t2, _this = this;
      _this.super$State$didChangeDependencies();
      t1 = _this._framework$_element;
      t1.toString;
      newRegistrar = B.SelectionContainer_maybeOf(t1);
      t1 = _this._scroll_delegate$_registrar;
      if (t1 != newRegistrar) {
        if (t1 != null) {
          t2 = _this._selectableAttachments;
          if (t2 != null)
            new B.LinkedHashMapKeysIterable(t2, B._instanceType(t2)._eval$1("LinkedHashMapKeysIterable<1>")).forEach$1(0, t1.get$remove(t1));
        }
        _this._scroll_delegate$_registrar = newRegistrar;
        if (newRegistrar != null) {
          t1 = _this._selectableAttachments;
          if (t1 != null)
            new B.LinkedHashMapKeysIterable(t1, B._instanceType(t1)._eval$1("LinkedHashMapKeysIterable<1>")).forEach$1(0, newRegistrar.get$add(newRegistrar));
        }
      }
    },
    add$1(_, selectable) {
      var t1, _this = this,
        attachment = _this.listensTo$1(selectable);
      selectable.addListener$1(attachment);
      t1 = _this._selectableAttachments;
      (t1 == null ? _this._selectableAttachments = B.LinkedHashMap_LinkedHashMap$_empty(type$.Selectable, type$.void_Function) : t1).$indexSet(0, selectable, attachment);
      _this._scroll_delegate$_registrar.add$1(0, selectable);
      if (selectable.get$value().status !== C.SelectionStatus_2)
        _this._updateSelectablesWithSelections$2$add(selectable, true);
    },
    remove$1(_, selectable) {
      var t1 = this._selectableAttachments;
      if (t1 == null)
        return;
      t1 = t1.remove$1(0, selectable);
      t1.toString;
      selectable.removeListener$1(t1);
      this._scroll_delegate$_registrar.remove$1(0, selectable);
      this._updateSelectablesWithSelections$2$add(selectable, false);
    },
    dispose$0() {
      var t2, t3, _this = this,
        t1 = _this._selectableAttachments;
      if (t1 != null) {
        for (t1 = new B.LinkedHashMapKeyIterator(t1, t1._modifications, t1._first); t1.moveNext$0();) {
          t2 = t1.__js_helper$_current;
          _this._scroll_delegate$_registrar.remove$1(0, t2);
          t3 = _this._selectableAttachments.$index(0, t2);
          t3.toString;
          t2.removeListener$1(t3);
        }
        _this._selectableAttachments = null;
      }
      _this._selectablesWithSelections = null;
      _this.super$State$dispose();
    },
    build$1(context) {
      var _this = this;
      _this.super$AutomaticKeepAliveClientMixin$build(context);
      if (_this._scroll_delegate$_registrar == null)
        return _this._widget.child;
      return B.SelectionRegistrarScope$(_this._widget.child, _this);
    }
  };
  A.__SelectionKeepAliveState_State_AutomaticKeepAliveClientMixin.prototype = {
    initState$0() {
      this.super$State$initState();
      if (this._wantKeepAlive)
        this._ensureKeepAlive$0();
    },
    deactivate$0() {
      var t1 = this.AutomaticKeepAliveClientMixin__keepAliveHandle;
      if (t1 != null) {
        t1.notifyListeners$0();
        t1.super$ChangeNotifier$dispose();
        this.AutomaticKeepAliveClientMixin__keepAliveHandle = null;
      }
      this.super$State$deactivate();
    }
  };
  A.ScrollView.prototype = {
    buildViewport$4(context, offset, axisDirection, slivers) {
      return new A.Viewport(axisDirection, 0, offset, null, this.cacheExtent, this.clipBehavior, slivers, null);
    },
    build$1(context) {
      var scrollController, scrollable, scrollableResult, _this = this, _null = null,
        sliver = _this.buildChildLayout$1(context),
        slivers = B._setArrayType([new A.SliverPadding(_this.padding, sliver, _null)], type$.JSArray_Widget),
        t1 = _this.scrollDirection,
        axisDirection = E.getAxisDirectionFromAxisReverseAndDirectionality(context, t1, false),
        effectivePrimary = _this.primary;
      effectivePrimary = E.PrimaryScrollController_shouldInherit(context, t1);
      scrollController = effectivePrimary ? B.PrimaryScrollController_maybeOf(context) : _this.controller;
      scrollable = F.Scrollable$(axisDirection, _this.clipBehavior, scrollController, _this.dragStartBehavior, false, _this.hitTestBehavior, _null, _this.physics, _this.restorationId, _null, _this.semanticChildCount, new A.ScrollView_build_closure(_this, axisDirection, slivers));
      scrollableResult = effectivePrimary && scrollController != null ? E.PrimaryScrollController$none(scrollable) : scrollable;
      if (_this.keyboardDismissBehavior === G.ScrollViewKeyboardDismissBehavior_1)
        return new B.NotificationListener(new A.ScrollView_build_closure0(context), scrollableResult, _null, type$.NotificationListener_ScrollUpdateNotification);
      else
        return scrollableResult;
    }
  };
  A.BoxScrollView.prototype = {};
  A.ListView.prototype = {
    buildChildLayout$1(context) {
      return new A.SliverList(this.childrenDelegate, null);
    }
  };
  A.SliverWithKeepAliveWidget.prototype = {};
  A.SliverMultiBoxAdaptorWidget.prototype = {
    createElement$0() {
      return A.SliverMultiBoxAdaptorElement$(this, false);
    }
  };
  A.SliverList.prototype = {
    createElement$0() {
      return A.SliverMultiBoxAdaptorElement$(this, true);
    },
    createRenderObject$1(context) {
      var t1 = new A.RenderSliverList(type$.SliverMultiBoxAdaptorElement._as(context), B.LinkedHashMap_LinkedHashMap$_empty(type$.int, type$.RenderBox), 0, null, null, B.LayerHandle$());
      t1.RenderObject$0();
      return t1;
    }
  };
  A.SliverMultiBoxAdaptorElement.prototype = {
    get$renderObject() {
      return type$.RenderSliverMultiBoxAdaptor._as(B.RenderObjectElement.prototype.get$renderObject.call(this));
    },
    update$1(newWidget) {
      var newDelegate, oldDelegate,
        t1 = this._widget;
      t1.toString;
      type$.SliverMultiBoxAdaptorWidget._as(t1);
      this.super$RenderObjectElement$update(newWidget);
      newDelegate = newWidget.delegate;
      oldDelegate = t1.delegate;
      t1 = newDelegate !== oldDelegate;
      if (t1) {
        B.getRuntimeTypeOfDartObject(newDelegate);
        B.getRuntimeTypeOfDartObject(oldDelegate);
      }
      if (t1)
        this.performRebuild$0();
    },
    performRebuild$0() {
      var newChildren, indexToLayoutOffset, adaptorWidget, processElement, index, key, newIndex, childParentData, lastKey, rightBoundary, t1, t2, t3, t4, t5, _i, t6, lastKey0, _this = this, _null = null, _box_0 = {};
      _this.super$RenderObjectElement$performRebuild();
      _this._currentBeforeChild = null;
      _box_0.childrenUpdated = false;
      try {
        t1 = type$.int;
        newChildren = A.SplayTreeMap$(t1, type$.nullable_Element);
        indexToLayoutOffset = B.HashMap_HashMap(_null, _null, _null, t1, type$.double);
        t1 = _this._widget;
        t1.toString;
        adaptorWidget = type$.SliverMultiBoxAdaptorWidget._as(t1);
        processElement = new A.SliverMultiBoxAdaptorElement_performRebuild_processElement(_box_0, _this, newChildren, adaptorWidget, indexToLayoutOffset);
        for (t1 = _this._childElements, t2 = t1.$ti._eval$1("_SplayTreeKeyIterable<1,_SplayTreeMapNode<1,2>>"), t2 = B.List_List$of(new A._SplayTreeKeyIterable(t1, t2), true, t2._eval$1("Iterable.E")), t3 = t2.length, t4 = type$.nullable_SliverMultiBoxAdaptorParentData, t5 = _this._replaceMovedChildren, _i = 0; _i < t3; ++_i) {
          index = t2[_i];
          t6 = t1._untypedLookup$1(index);
          key = (t6 == null ? _null : t6.value)._widget.key;
          newIndex = key == null ? _null : adaptorWidget.delegate.findIndexByKey$1(key);
          t6 = t1._untypedLookup$1(index);
          t6 = (t6 == null ? _null : t6.value).get$renderObject();
          childParentData = t4._as(t6 == null ? _null : t6.parentData);
          if (childParentData != null && childParentData.layoutOffset != null) {
            t6 = childParentData.layoutOffset;
            t6.toString;
            J.$indexSet$ax(indexToLayoutOffset, index, t6);
          }
          if (newIndex != null && !J.$eq$(newIndex, index)) {
            if (childParentData != null)
              childParentData.layoutOffset = null;
            t6 = t1._untypedLookup$1(index);
            t6 = t6 == null ? _null : t6.value;
            J.$indexSet$ax(newChildren, newIndex, t6);
            if (t5)
              newChildren.putIfAbsent$2(index, new A.SliverMultiBoxAdaptorElement_performRebuild_closure());
            t1.remove$1(0, index);
          } else
            newChildren.putIfAbsent$2(index, new A.SliverMultiBoxAdaptorElement_performRebuild_closure0(_this, index));
        }
        _this.get$renderObject();
        t2 = newChildren;
        new A._SplayTreeKeyIterable(t2, t2.$ti._eval$1("_SplayTreeKeyIterable<1,_SplayTreeMapNode<1,2>>")).forEach$1(0, processElement);
        if (!_box_0.childrenUpdated && _this._didUnderflow) {
          lastKey0 = t1.lastKey$0();
          lastKey = lastKey0 == null ? -1 : lastKey0;
          rightBoundary = lastKey + 1;
          J.$indexSet$ax(newChildren, rightBoundary, t1.$index(0, rightBoundary));
          processElement.call$1(rightBoundary);
        }
      } finally {
        _this._currentlyUpdatingChildIndex = null;
        _this.get$renderObject();
      }
    },
    createChild$2$after(index, after) {
      this._framework$_owner.buildScope$2(this, new A.SliverMultiBoxAdaptorElement_createChild_closure(this, after, index));
    },
    updateChild$3(child, newWidget, newSlot) {
      var t1, t2, newChild, t3, _null = null;
      if (child == null)
        t1 = _null;
      else {
        t1 = child.get$renderObject();
        t1 = t1 == null ? _null : t1.parentData;
      }
      t2 = type$.nullable_SliverMultiBoxAdaptorParentData;
      t2._as(t1);
      newChild = this.super$Element$updateChild(child, newWidget, newSlot);
      if (newChild == null)
        t3 = _null;
      else {
        t3 = newChild.get$renderObject();
        t3 = t3 == null ? _null : t3.parentData;
      }
      t2._as(t3);
      if (t1 != t3 && t1 != null && t3 != null)
        t3.layoutOffset = t1.layoutOffset;
      return newChild;
    },
    forgetChild$1(child) {
      this._childElements.remove$1(0, child._slot);
      this.super$Element$forgetChild(child);
    },
    removeChild$1(child) {
      var t1, _this = this;
      _this.get$renderObject();
      t1 = child.parentData;
      t1.toString;
      t1 = type$.SliverMultiBoxAdaptorParentData._as(t1).index;
      t1.toString;
      _this._framework$_owner.buildScope$2(_this, new A.SliverMultiBoxAdaptorElement_removeChild_closure(_this, t1));
    },
    estimateMaxScrollOffset$5$firstIndex$lastIndex$leadingScrollOffset$trailingScrollOffset(constraints, firstIndex, lastIndex, leadingScrollOffset, trailingScrollOffset) {
      var t1 = this._widget;
      t1.toString;
      type$.SliverMultiBoxAdaptorWidget._as(t1);
      leadingScrollOffset.toString;
      t1 = A.SliverMultiBoxAdaptorElement__extrapolateMaxScrollOffset(firstIndex, lastIndex, leadingScrollOffset, trailingScrollOffset, t1.delegate.childCount);
      return t1;
    },
    didFinishLayout$0() {
      var t1 = this._childElements;
      t1.firstKey$0();
      t1.lastKey$0();
      t1 = this._widget;
      t1.toString;
      type$.SliverMultiBoxAdaptorWidget._as(t1);
    },
    didAdoptChild$1(child) {
      var t1 = child.parentData;
      t1.toString;
      type$.SliverMultiBoxAdaptorParentData._as(t1).index = this._currentlyUpdatingChildIndex;
    },
    insertRenderObjectChild$2(child, slot) {
      this.get$renderObject().super$ContainerRenderObjectMixin$insert(0, type$.RenderBox._as(child), this._currentBeforeChild);
    },
    moveRenderObjectChild$3(child, oldSlot, newSlot) {
      this.get$renderObject().move$2$after(type$.RenderBox._as(child), this._currentBeforeChild);
    },
    removeRenderObjectChild$2(child, slot) {
      this.get$renderObject().remove$1(0, type$.RenderBox._as(child));
    },
    visitChildren$1(visitor) {
      var t1 = this._childElements,
        t2 = t1.$ti._eval$1("_SplayTreeValueIterable<1,2>");
      t2 = B.CastIterable_CastIterable(new A._SplayTreeValueIterable(t1, t2), t2._eval$1("Iterable.E"), type$.Element);
      C.JSArray_methods.forEach$1(B.List_List$of(t2, true, B._instanceType(t2)._eval$1("Iterable.E")), visitor);
    }
  };
  A.KeepAlive.prototype = {
    applyParentData$1(renderObject) {
      var t2,
        t1 = renderObject.parentData;
      t1.toString;
      type$.KeepAliveParentDataMixin._as(t1);
      t2 = this.keepAlive;
      if (t1.KeepAliveParentDataMixin_keepAlive !== t2) {
        t1.KeepAliveParentDataMixin_keepAlive = t2;
        if (!t2) {
          t1 = renderObject.get$parent();
          if (t1 != null)
            t1.markNeedsLayout$0();
        }
      }
    }
  };
  A.Viewport.prototype = {
    createRenderObject$1(context) {
      var _this = this,
        t1 = _this.axisDirection,
        t2 = A.Viewport_getDefaultCrossAxisDirection(context, t1),
        t3 = B.LayerHandle$();
      t1 = new A.RenderViewport(_this.anchor, t1, t2, _this.offset, 250, D.CacheExtentStyle_0, _this.clipBehavior, t3, 0, null, null, new B._LayoutCacheStorage(), B.LayerHandle$());
      t1.RenderObject$0();
      t1.addAll$1(0, null);
      t2 = t1.ContainerRenderObjectMixin__firstChild;
      if (t2 != null)
        t1._center = t2;
      return t1;
    },
    updateRenderObject$2(context, renderObject) {
      var _this = this,
        t1 = _this.axisDirection;
      renderObject.set$axisDirection(t1);
      t1 = A.Viewport_getDefaultCrossAxisDirection(context, t1);
      renderObject.set$crossAxisDirection(t1);
      renderObject.set$anchor(_this.anchor);
      renderObject.set$offset(_this.offset);
      renderObject.set$cacheExtent(_this.cacheExtent);
      renderObject.set$cacheExtentStyle(D.CacheExtentStyle_0);
      renderObject.set$clipBehavior(_this.clipBehavior);
    },
    createElement$0() {
      return new A._ViewportElement(B.HashSet_HashSet(type$.Element), this, C._ElementLifecycle_0);
    }
  };
  A._ViewportElement.prototype = {
    get$renderObject() {
      return type$.RenderViewport._as(B.MultiChildRenderObjectElement.prototype.get$renderObject.call(this));
    },
    mount$2($parent, newSlot) {
      var _this = this;
      _this._doingMountOrUpdate = true;
      _this.super$MultiChildRenderObjectElement$mount($parent, newSlot);
      _this._updateCenter$0();
      _this._doingMountOrUpdate = false;
    },
    update$1(newWidget) {
      var _this = this;
      _this._doingMountOrUpdate = true;
      _this.super$MultiChildRenderObjectElement$update(newWidget);
      _this._updateCenter$0();
      _this._doingMountOrUpdate = false;
    },
    _updateCenter$0() {
      var _this = this,
        t1 = _this._widget;
      t1.toString;
      type$.Viewport._as(t1);
      t1 = type$.RenderViewport;
      if (!_this.get$children().get$isEmpty(0)) {
        t1._as(B.MultiChildRenderObjectElement.prototype.get$renderObject.call(_this)).set$center(type$.nullable_RenderSliver._as(_this.get$children().get$first(0).get$renderObject()));
        _this._centerSlotIndex = 0;
      } else {
        t1._as(B.MultiChildRenderObjectElement.prototype.get$renderObject.call(_this)).set$center(null);
        _this._centerSlotIndex = null;
      }
    },
    insertRenderObjectChild$2(child, slot) {
      var _this = this;
      _this.super$MultiChildRenderObjectElement$insertRenderObjectChild(child, slot);
      if (!_this._doingMountOrUpdate && slot.index === _this._centerSlotIndex)
        type$.RenderViewport._as(B.MultiChildRenderObjectElement.prototype.get$renderObject.call(_this)).set$center(type$.nullable_RenderSliver._as(child));
    },
    moveRenderObjectChild$3(child, oldSlot, newSlot) {
      this.super$MultiChildRenderObjectElement$moveRenderObjectChild(child, oldSlot, newSlot);
    },
    removeRenderObjectChild$2(child, slot) {
      var _this = this;
      _this.super$MultiChildRenderObjectElement$removeRenderObjectChild(child, slot);
      if (!_this._doingMountOrUpdate && type$.RenderViewport._as(B.MultiChildRenderObjectElement.prototype.get$renderObject.call(_this))._center === child)
        type$.RenderViewport._as(B.MultiChildRenderObjectElement.prototype.get$renderObject.call(_this)).set$center(null);
    }
  };
  A.__ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin.prototype = {};
  A.__ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin_ViewportElementMixin.prototype = {};
  A.Animate.prototype = {
    createState$0() {
      return new A._AnimateState(null, null);
    },
    addEffect$1(effect) {
      var delay, t2, entry, _this = this,
        prior = _this._lastEntry,
        t1 = effect.delay;
      if (t1 != null)
        delay = new B.Duration(_this._baseDelay._duration + t1._duration);
      else {
        delay = prior == null ? null : prior.delay;
        if (delay == null)
          delay = _this._baseDelay;
      }
      t1 = effect.duration;
      if (t1 == null)
        t1 = prior == null ? null : prior.duration;
      if (t1 == null)
        t1 = C.Duration_300000;
      t2 = effect.curve;
      if (t2 == null)
        t2 = prior == null ? null : prior.curve;
      entry = new A.EffectEntry(delay, t1, t2 == null ? C.C__Linear : t2, effect);
      t2 = _this.__Animate__entries_F;
      t2 === $ && B.throwUnnamedLateFieldNI();
      t2.push(entry);
      _this._lastEntry = entry;
      t1 = delay._duration + t1._duration;
      t2 = _this._animate$_duration;
      if (t1 > t2._duration)
        _this._animate$_duration = new B.Duration(t1);
      return _this;
    }
  };
  A._AnimateState.prototype = {
    initState$0() {
      this.super$State$initState();
      this._restart$0();
    },
    didUpdateWidget$1(oldWidget) {
      var _this = this,
        t1 = _this._widget,
        t2 = oldWidget._animate$_duration;
      t1 = t1._animate$_duration;
      t1 = t2._duration !== t1._duration;
      if (t1) {
        _this._initController$0();
        _this._play$0();
      }
      _this.super$State$didUpdateWidget(oldWidget);
    },
    _restart$0() {
      var _this = this,
        t1 = _this._delayed;
      if (t1 != null)
        B.FutureExtensions_ignore(t1, type$.void);
      _this._initController$0();
      _this._updateValue$0();
      _this._delayed = B.Future_Future$delayed(_this._widget.delay, new A._AnimateState__restart_closure(_this), type$.void);
    },
    _initController$0() {
      var callback, controller, t1, _this = this, _null = null;
      _this._widget.toString;
      callback = !_this._isInternalController;
      if (callback) {
        controller = B.AnimationController$(_null, _null, _null, _null, _this);
        _this._isInternalController = true;
      } else
        controller = _null;
      if (controller != null) {
        _this.___AnimateState__controller_A = controller;
        controller.didRegisterListener$0();
        t1 = controller.AnimationLocalStatusListenersMixin__statusListeners;
        t1._isDirty = true;
        t1._list.push(_this.get$_handleAnimationStatus());
      }
      t1 = _this.___AnimateState__controller_A;
      t1 === $ && B.throwUnnamedLateFieldNI();
      t1.duration = _this._widget._animate$_duration;
      _this._initAdapter$0();
      if (callback)
        _this._widget.toString;
    },
    _initAdapter$0() {
      this._adapter = this._widget.adapter;
    },
    _disposeController$0() {
      if (this._isInternalController) {
        var t1 = this.___AnimateState__controller_A;
        t1 === $ && B.throwUnnamedLateFieldNI();
        t1.dispose$0();
      }
      this._isInternalController = false;
    },
    dispose$0() {
      var t1 = this._delayed;
      if (t1 != null)
        B.FutureExtensions_ignore(t1, type$.void);
      this._disposeController$0();
      this.super$__AnimateState_State_SingleTickerProviderStateMixin$dispose();
    },
    _handleAnimationStatus$1($status) {
      if (J.$eq$($status, C.AnimationStatus_3))
        this._widget.toString;
    },
    _play$0() {
      var _this = this,
        t1 = _this._delayed;
      if (t1 != null)
        B.FutureExtensions_ignore(t1, type$.void);
      _this._updateValue$0();
      _this._widget.toString;
      t1 = _this.___AnimateState__controller_A;
      t1 === $ && B.throwUnnamedLateFieldNI();
      t1.forward$1$from(0);
      _this._widget.toString;
    },
    _updateValue$0() {
      this._widget.toString;
      return;
    },
    build$1(context) {
      var t3, _i, entry, t4,
        child = this._widget.child,
        reparent = $.$get$Animate_reparentTypes().$index(0, B.getRuntimeTypeOfDartObject(child)),
        t1 = reparent == null,
        child0 = !t1 ? child.get$child() : child,
        t2 = this._widget.__Animate__entries_F;
      t2 === $ && B.throwUnnamedLateFieldNI();
      t3 = t2.length;
      _i = 0;
      for (; _i < t2.length; t2.length === t3 || (0, B.throwConcurrentModificationError)(t2), ++_i) {
        entry = t2[_i];
        t4 = this.___AnimateState__controller_A;
        t4 === $ && B.throwUnnamedLateFieldNI();
        child0 = entry.effect.build$4(context, child0, t4, entry);
      }
      t1 = t1 ? null : reparent.call$2(child, child0);
      return t1 == null ? child0 : t1;
    }
  };
  A._Animate_StatefulWidget_AnimateManager.prototype = {};
  A.__AnimateState_State_SingleTickerProviderStateMixin.prototype = {
    dispose$0() {
      var _this = this,
        t1 = _this.SingleTickerProviderStateMixin__tickerModeNotifier;
      if (t1 != null)
        t1.removeListener$1(_this.get$_updateTicker());
      _this.SingleTickerProviderStateMixin__tickerModeNotifier = null;
      _this.super$State$dispose();
    },
    activate$0() {
      this.super$State$activate();
      this._updateTickerModeNotifier$0();
      this._updateTicker$0();
    }
  };
  A.Effect.prototype = {
    buildAnimation$2(controller, entry) {
      var beginT,
        t1 = controller.duration,
        ttlT = t1 == null ? null : t1._duration;
      if (ttlT == null)
        ttlT = 0;
      beginT = entry.delay._duration;
      t1 = B._instanceType(this)._eval$1("Tween<Effect.T>");
      return new B._AnimatedEvaluation(type$.Animation_double._as(B.CurvedAnimation$(new B.Interval(beginT / ttlT, (beginT + entry.duration._duration) / ttlT, entry.curve), controller, null)), new B.Tween(this.begin, this.end, t1), t1._eval$1("_AnimatedEvaluation<Animatable.T>"));
    }
  };
  A.FadeEffect.prototype = {
    build$4(context, child, controller, entry) {
      return new B.FadeTransition(this.buildAnimation$2(controller, entry), false, child, null);
    }
  };
  A.SlideEffect.prototype = {
    build$4(context, child, controller, entry) {
      return B.SlideTransition$(child, this.buildAnimation$2(controller, entry), null, true);
    }
  };
  A.AnimateManager.prototype = {};
  A.EffectEntry.prototype = {};
  A.ProviderFamilyBuilder.prototype = {
    call$2$1(create, State, Arg) {
      var _null = null;
      return new A.ProviderFamily(B.instantiate1(A.provider_Provider___internal_tearOff$closure(), State), create, _null, _null, B.computeAllTransitiveDependencies(_null), _null, State._eval$1("@<0>")._bind$1(Arg)._eval$1("ProviderFamily<1,2>"));
    },
    call$1(create) {
      var t1 = type$.dynamic;
      return this.call$2$1(create, t1, t1);
    }
  };
  A.StreamProviderFamilyBuilder.prototype = {
    call$2$1(create, State, Arg) {
      var _null = null;
      return new A.StreamProviderFamily(B.instantiate1(A.stream_provider_StreamProvider___internal_tearOff$closure(), State), create, _null, _null, B.computeAllTransitiveDependencies(_null), _null, State._eval$1("@<0>")._bind$1(Arg)._eval$1("StreamProviderFamily<1,2>"));
    },
    call$1(create) {
      var t1 = type$.dynamic;
      return this.call$2$1(create, t1, t1);
    }
  };
  A.Family.prototype = {
    get$from() {
      return null;
    },
    $isOverride: 1,
    $isProviderOrFamily: 1
  };
  A._FamilyMixin.prototype = {
    getProviderOverride$1(provider) {
      return this.call$1(B._instanceType(this)._eval$1("_FamilyMixin.1")._as(provider.argument));
    }
  };
  A.FamilyBase.prototype = {
    call$1(argument) {
      var _this = this;
      return _this._providerFactory.call$7$allTransitiveDependencies$argument$debugGetCreateSourceHash$dependencies$from$name(new A.FamilyBase_call_closure(_this, argument), _this.allTransitiveDependencies, argument, _this.debugGetCreateSourceHash, _this.dependencies, _this, _this.name);
    },
    get$dependencies() {
      return this.dependencies;
    }
  };
  A._FamilyBase_Family__FamilyMixin.prototype = {};
  A.ProviderFamily.prototype = {};
  A.StreamProviderFamily.prototype = {};
  var typesOffset = hunkHelpers.updateTypes(["double(double)", "~(SliverConstraints)", "~(Selectable0)", "bool(SliverHitTestResult{crossAxisPosition!double,mainAxisPosition!double})", "~(PaintingContext,Offset)", "~({curve:Curve,descendant:RenderObject?,duration:Duration,rect:Rect?})", "bool(RenderSliver)", "bool(KeepAliveNotification)", "~(RenderBox)", "~(@)", "int(Widget,int)", "Provider<0^>(0^(ProviderRef<0^>){allTransitiveDependencies!Iterable<ProviderOrFamily>?,argument:Object?,debugGetCreateSourceHash!String()?,dependencies!Iterable<ProviderOrFamily>?,from:Family<Object?>?,name!String?})<Object?>", "StreamProvider<0^>(Stream<0^>(StreamProviderRef<0^>){allTransitiveDependencies!Iterable<ProviderOrFamily>?,argument:Object?,debugGetCreateSourceHash!String()?,dependencies!Iterable<ProviderOrFamily>?,from:Family<Object?>?,name!String?})<Object?>"]);
  A.RenderSliverHelpers_hitTestBoxChild_closure.prototype = {
    call$1(result) {
      return this.child.hitTest$2$position(result, this._box_0.transformedPosition);
    },
    $signature: 196
  };
  A.RenderSliverList_performLayout_advance.prototype = {
    call$0() {
      var t4, child, t5,
        t1 = this._box_0,
        t2 = t1.child,
        t3 = t1.trailingChildWithLayout;
      if (t2 == t3)
        t1.inLayoutRange = false;
      t4 = this.$this;
      t2 = t2.parentData;
      t2.toString;
      child = t1.child = B._instanceType(t4)._eval$1("ContainerRenderObjectMixin.1")._as(t2).ContainerParentDataMixin_nextSibling;
      t2 = child == null;
      if (t2)
        t1.inLayoutRange = false;
      t5 = ++t1.index;
      if (!t1.inLayoutRange) {
        if (!t2) {
          t2 = child.parentData;
          t2.toString;
          t2 = type$.SliverMultiBoxAdaptorParentData._as(t2).index;
          t2.toString;
          t5 = t2 !== t5;
          t2 = t5;
        } else
          t2 = true;
        t5 = this.childConstraints;
        if (t2) {
          child = t4.insertAndLayoutChild$3$after$parentUsesSize(t5, t3, true);
          t1.child = child;
          if (child == null)
            return false;
        } else
          child.layout$2$parentUsesSize(t5, true);
        t2 = t1.trailingChildWithLayout = t1.child;
      } else
        t2 = child;
      t3 = t2.parentData;
      t3.toString;
      type$.SliverMultiBoxAdaptorParentData._as(t3);
      t5 = t1.endScrollOffset;
      t3.layoutOffset = t5;
      t1.endScrollOffset = t5 + t4.paintExtentOf$1(t2);
      return true;
    },
    $signature: 67
  };
  A.RenderSliverMultiBoxAdaptor__createOrObtainChild_closure.prototype = {
    call$1(constraints) {
      var child,
        t1 = this.$this,
        t2 = t1._keepAliveBucket,
        t3 = this.index,
        t4 = this.after;
      if (t2.containsKey$1(t3)) {
        child = t2.remove$1(0, t3);
        t2 = child.parentData;
        t2.toString;
        type$.SliverMultiBoxAdaptorParentData._as(t2);
        t1.dropChild$1(child);
        child.parentData = t2;
        t1.super$ContainerRenderObjectMixin$insert(0, child, t4);
        t2._keptAlive = false;
      } else
        t1._childManager.createChild$2$after(t3, t4);
    },
    $signature: typesOffset + 1
  };
  A.RenderSliverMultiBoxAdaptor_collectGarbage_closure.prototype = {
    call$1(constraints) {
      var t1, t2, t3, t4;
      for (t1 = this._box_0, t2 = this.$this; t1.leadingGarbage > 0;) {
        t3 = t2.ContainerRenderObjectMixin__firstChild;
        t3.toString;
        t2._destroyOrCacheChild$1(t3);
        --t1.leadingGarbage;
      }
      for (; t1.trailingGarbage > 0;) {
        t3 = t2.ContainerRenderObjectMixin__lastChild;
        t3.toString;
        t2._destroyOrCacheChild$1(t3);
        --t1.trailingGarbage;
      }
      t1 = t2._keepAliveBucket;
      t3 = B._instanceType(t1)._eval$1("LinkedHashMapValuesIterable<2>");
      t4 = t3._eval$1("WhereIterable<Iterable.E>");
      C.JSArray_methods.forEach$1(B.List_List$of(new B.WhereIterable(new B.LinkedHashMapValuesIterable(t1, t3), new A.RenderSliverMultiBoxAdaptor_collectGarbage__closure(), t4), true, t4._eval$1("Iterable.E")), t2._childManager.get$removeChild());
    },
    $signature: typesOffset + 1
  };
  A.RenderSliverMultiBoxAdaptor_collectGarbage__closure.prototype = {
    call$1(child) {
      var t1 = child.parentData;
      t1.toString;
      return !type$.SliverMultiBoxAdaptorParentData._as(t1).KeepAliveParentDataMixin_keepAlive;
    },
    $signature: 546
  };
  A.RenderSliverEdgeInsetsPadding_performLayout_paintOffset.prototype = {
    call$2$from$to(from, to) {
      return this.$this.calculatePaintOffset$3$from$to(this.constraints, from, to);
    },
    $signature: 197
  };
  A.RenderSliverEdgeInsetsPadding_performLayout_cacheOffset.prototype = {
    call$2$from$to(from, to) {
      return this.$this.calculateCacheOffset$3$from$to(this.constraints, from, to);
    },
    $signature: 197
  };
  A.RenderViewportBase_visitChildrenForSemantics_closure.prototype = {
    call$1(sliver) {
      var t1 = sliver._geometry;
      return t1.visible || t1.cacheExtent > 0;
    },
    $signature: typesOffset + 6
  };
  A.RenderViewportBase_hitTestChildren_closure.prototype = {
    call$1(result) {
      var _this = this,
        t1 = _this.child,
        t2 = _this._box_0,
        t3 = _this.$this.computeChildMainAxisPosition$2(t1, t2.mainAxisPosition);
      return t1.hitTest$3$crossAxisPosition$mainAxisPosition(_this.sliverResult, t2.crossAxisPosition, t3);
    },
    $signature: 196
  };
  A._AutomaticKeepAliveState__addClient_closure.prototype = {
    call$1(timeStamp) {
      var childElement,
        t1 = this.$this;
      if (t1._framework$_element == null)
        return;
      childElement = t1._getChildElement$0();
      childElement.toString;
      t1._updateParentDataOfChild$1(childElement);
    },
    $signature: 6
  };
  A._AutomaticKeepAliveState__getChildElement_closure.prototype = {
    call$1(child) {
      this._box_0.childElement = child;
    },
    $signature: 12
  };
  A._AutomaticKeepAliveState__createCallback_closure.prototype = {
    call$0() {
      var t1 = this.$this,
        t2 = this.handle;
      t1._automatic_keep_alive$_handles.remove$1(0, t2);
      t2.removeListener$1(this.callback._readLocal$0());
      if (t1._automatic_keep_alive$_handles.__js_helper$_length === 0)
        if ($.SchedulerBinding__instance.SchedulerBinding__schedulerPhase.index < 3)
          t1.setState$1(new A._AutomaticKeepAliveState__createCallback__closure(t1));
        else {
          t1._keepingAlive = false;
          B.scheduleMicrotask(new A._AutomaticKeepAliveState__createCallback__closure0(t1));
        }
    },
    $signature: 0
  };
  A._AutomaticKeepAliveState__createCallback__closure.prototype = {
    call$0() {
      this.$this._keepingAlive = false;
    },
    $signature: 0
  };
  A._AutomaticKeepAliveState__createCallback__closure0.prototype = {
    call$0() {
      var t1 = this.$this;
      if (t1._framework$_element != null && t1._automatic_keep_alive$_handles.__js_helper$_length === 0)
        t1.setState$1(new A._AutomaticKeepAliveState__createCallback___closure());
    },
    $signature: 0
  };
  A._AutomaticKeepAliveState__createCallback___closure.prototype = {
    call$0() {
    },
    $signature: 0
  };
  A._SelectionKeepAliveState_listensTo_closure.prototype = {
    call$0() {
      var t1 = this.selectable,
        t2 = this.$this;
      if (t1.get$value().status !== C.SelectionStatus_2)
        t2._updateSelectablesWithSelections$2$add(t1, true);
      else
        t2._updateSelectablesWithSelections$2$add(t1, false);
    },
    $signature: 0
  };
  A.ScrollView_build_closure.prototype = {
    call$2(context, offset) {
      return this.$this.buildViewport$4(context, offset, this.axisDirection, this.slivers);
    },
    $signature: 548
  };
  A.ScrollView_build_closure0.prototype = {
    call$1(notification) {
      var t1,
        currentScope = B.FocusScope_of(this.context);
      if (notification.dragDetails != null && !currentScope.get$hasPrimaryFocus() && currentScope.get$hasFocus()) {
        t1 = $.WidgetsBinding__instance.WidgetsBinding__buildOwner.focusManager._primaryFocus;
        if (t1 != null)
          t1.unfocus$0();
      }
      return false;
    },
    $signature: 549
  };
  A.SliverMultiBoxAdaptorElement_performRebuild_processElement.prototype = {
    call$1(index) {
      var newChild, parentData, t2, t3, _this = this,
        t1 = _this.$this;
      t1._currentlyUpdatingChildIndex = index;
      t2 = t1._childElements;
      if (t2.$index(0, index) != null && !J.$eq$(t2.$index(0, index), _this.newChildren.$index(0, index))) {
        t2.$indexSet(0, index, t1.updateChild$3(t2.$index(0, index), null, index));
        _this._box_0.childrenUpdated = true;
      }
      newChild = t1.updateChild$3(_this.newChildren.$index(0, index), _this.adaptorWidget.delegate.build$2(t1, index), index);
      if (newChild != null) {
        t3 = _this._box_0;
        t3.childrenUpdated = t3.childrenUpdated || !J.$eq$(t2.$index(0, index), newChild);
        t2.$indexSet(0, index, newChild);
        t2 = newChild.get$renderObject().parentData;
        t2.toString;
        parentData = type$.SliverMultiBoxAdaptorParentData._as(t2);
        if (index === 0)
          parentData.layoutOffset = 0;
        else {
          t2 = _this.indexToLayoutOffset;
          if (t2.containsKey$1(index))
            parentData.layoutOffset = t2.$index(0, index);
        }
        if (!parentData._keptAlive)
          t1._currentBeforeChild = type$.nullable_RenderBox._as(newChild.get$renderObject());
      } else {
        _this._box_0.childrenUpdated = true;
        t2.remove$1(0, index);
      }
    },
    $signature: 25
  };
  A.SliverMultiBoxAdaptorElement_performRebuild_closure.prototype = {
    call$0() {
      return null;
    },
    $signature: 22
  };
  A.SliverMultiBoxAdaptorElement_performRebuild_closure0.prototype = {
    call$0() {
      return this.$this._childElements.$index(0, this.index);
    },
    $signature: 550
  };
  A.SliverMultiBoxAdaptorElement_createChild_closure.prototype = {
    call$0() {
      var newChild, adaptorWidget, t2, _this = this,
        t1 = _this.$this;
      t1._currentBeforeChild = _this.after == null ? null : type$.nullable_RenderBox._as(t1._childElements.$index(0, _this.index - 1).get$renderObject());
      newChild = null;
      try {
        t2 = t1._widget;
        t2.toString;
        adaptorWidget = type$.SliverMultiBoxAdaptorWidget._as(t2);
        t2 = t1._currentlyUpdatingChildIndex = _this.index;
        newChild = t1.updateChild$3(t1._childElements.$index(0, t2), adaptorWidget.delegate.build$2(t1, t2), t2);
      } finally {
        t1._currentlyUpdatingChildIndex = null;
      }
      t2 = _this.index;
      t1 = t1._childElements;
      if (newChild != null)
        t1.$indexSet(0, t2, newChild);
      else
        t1.remove$1(0, t2);
    },
    $signature: 0
  };
  A.SliverMultiBoxAdaptorElement_removeChild_closure.prototype = {
    call$0() {
      var t1, t2, _this = this;
      try {
        t1 = _this.$this;
        t2 = t1._currentlyUpdatingChildIndex = _this.index;
        t1.updateChild$3(t1._childElements.$index(0, t2), null, t2);
      } finally {
        _this.$this._currentlyUpdatingChildIndex = null;
      }
      _this.$this._childElements.remove$1(0, _this.index);
    },
    $signature: 0
  };
  A.Animate_reparentTypes_closure.prototype = {
    call$2($parent, child) {
      type$.Flexible._as($parent);
      return new B.Flexible($parent.flex, $parent.fit, child, $parent.key);
    },
    $signature: 551
  };
  A.Animate_reparentTypes_closure0.prototype = {
    call$2($parent, child) {
      type$.Positioned._as($parent);
      return B.Positioned$($parent.bottom, child, $parent.height, $parent.key, $parent.left, $parent.right, $parent.top, $parent.width);
    },
    $signature: 552
  };
  A.Animate_reparentTypes_closure1.prototype = {
    call$2($parent, child) {
      type$.Expanded._as($parent);
      return B.Expanded$(child, $parent.flex, $parent.key);
    },
    $signature: 553
  };
  A._AnimateState__restart_closure.prototype = {
    call$0() {
      return this.$this._play$0();
    },
    $signature: 0
  };
  A.tasksForProjectProvider_closure.prototype = {
    call$2(ref, projectUuid) {
      return ref.watch$1$1($.$get$taskRepositoryProvider(), type$.TaskRepository).watchTasksForProjectUuid$1(projectUuid);
    },
    $signature: 554
  };
  A.FamilyBase_call_closure.prototype = {
    call$1(ref) {
      return this.$this._framework0$_createFn.call$2(ref, this.argument);
    },
    $signature() {
      return B._instanceType(this.$this)._eval$1("FamilyBase.3(FamilyBase.0)");
    }
  };
  (function aliases() {
    var _ = A.SliverLogicalParentData.prototype;
    _.super$SliverLogicalParentData$toString = _.toString$0;
    _ = A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin.prototype;
    _.super$_RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin$attach = _.attach$1;
    _.super$_RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin$detach = _.detach$0;
    _ = A.RenderSliverEdgeInsetsPadding.prototype;
    _.super$RenderSliverEdgeInsetsPadding$performLayout = _.performLayout$0;
    _ = A._RenderViewportBase_RenderBox_ContainerRenderObjectMixin.prototype;
    _.super$_RenderViewportBase_RenderBox_ContainerRenderObjectMixin$attach = _.attach$1;
    _.super$_RenderViewportBase_RenderBox_ContainerRenderObjectMixin$detach = _.detach$0;
    _ = A.__AnimateState_State_SingleTickerProviderStateMixin.prototype;
    _.super$__AnimateState_State_SingleTickerProviderStateMixin$dispose = _.dispose$0;
  })();
  (function installTearOffs() {
    var _instance = hunkHelpers.installInstanceTearOff,
      _instance_1_u = hunkHelpers._instance_1u,
      _instance_2_u = hunkHelpers._instance_2u,
      _static_2 = hunkHelpers._static_2,
      _instance_1_i = hunkHelpers._instance_1i,
      _static = hunkHelpers.installStaticTearOff;
    _instance(A.RenderSliver.prototype, "get$hitTest", 0, 1, null, ["call$3$crossAxisPosition$mainAxisPosition"], ["hitTest$3$crossAxisPosition$mainAxisPosition"], 3, 0, 0);
    var _;
    _instance_1_u(_ = A.RenderViewportBase.prototype, "get$computeMinIntrinsicWidth", "computeMinIntrinsicWidth$1", 0);
    _instance_1_u(_, "get$computeMaxIntrinsicWidth", "computeMaxIntrinsicWidth$1", 0);
    _instance_1_u(_, "get$computeMinIntrinsicHeight", "computeMinIntrinsicHeight$1", 0);
    _instance_1_u(_, "get$computeMaxIntrinsicHeight", "computeMaxIntrinsicHeight$1", 0);
    _instance_2_u(_, "get$_viewport$_paintContents", "_viewport$_paintContents$2", 4);
    _instance(_, "get$showOnScreen", 0, 0, null, ["call$4$curve$descendant$duration$rect", "call$0", "call$1$rect", "call$3$curve$duration$rect", "call$2$descendant$rect"], ["showOnScreen$4$curve$descendant$duration$rect", "showOnScreen$0", "showOnScreen$1$rect", "showOnScreen$3$curve$duration$rect", "showOnScreen$2$descendant$rect"], 5, 0, 0);
    _instance_1_u(A._AutomaticKeepAliveState.prototype, "get$_addClient", "_addClient$1", 7);
    _static_2(A, "scroll_delegate___kDefaultSemanticIndexCallback$closure", "_kDefaultSemanticIndexCallback", 10);
    _instance_1_i(_ = A._SelectionKeepAliveState.prototype, "get$add", "add$1", 2);
    _instance_1_i(_, "get$remove", "remove$1", 2);
    _instance_1_u(A.SliverMultiBoxAdaptorElement.prototype, "get$removeChild", "removeChild$1", 8);
    _instance_1_u(A._AnimateState.prototype, "get$_handleAnimationStatus", "_handleAnimationStatus$1", 9);
    _static(A, "provider_Provider___internal_tearOff$closure", 1, function() {
      return {allTransitiveDependencies: C.C__Required, argument: null, debugGetCreateSourceHash: C.C__Required, dependencies: C.C__Required, from: null, name: C.C__Required};
    }, ["call$1$7$allTransitiveDependencies$argument$debugGetCreateSourceHash$dependencies$from$name", "call$7$allTransitiveDependencies$argument$debugGetCreateSourceHash$dependencies$from$name", "call$7$allTransitiveDependencies$argument$debugGetCreateSourceHash$dependencies$from$name"], ["Provider___internal_tearOff", function(_createFn, allTransitiveDependencies, argument, debugGetCreateSourceHash, dependencies, from, $name) {
      return A.Provider___internal_tearOff(_createFn, allTransitiveDependencies, argument, debugGetCreateSourceHash, dependencies, from, $name, type$.dynamic);
    }, function(_createFn, allTransitiveDependencies, argument, debugGetCreateSourceHash, dependencies, from, $name) {
      return A.Provider___internal_tearOff(_createFn, allTransitiveDependencies, argument, debugGetCreateSourceHash, dependencies, from, $name, type$.dynamic);
    }], 11, 1);
    _static(A, "stream_provider_StreamProvider___internal_tearOff$closure", 1, function() {
      return {allTransitiveDependencies: C.C__Required, argument: null, debugGetCreateSourceHash: C.C__Required, dependencies: C.C__Required, from: null, name: C.C__Required};
    }, ["call$1$7$allTransitiveDependencies$argument$debugGetCreateSourceHash$dependencies$from$name", "call$7$allTransitiveDependencies$argument$debugGetCreateSourceHash$dependencies$from$name", "call$7$allTransitiveDependencies$argument$debugGetCreateSourceHash$dependencies$from$name"], ["StreamProvider___internal_tearOff", function(_createFn, allTransitiveDependencies, argument, debugGetCreateSourceHash, dependencies, from, $name) {
      return A.StreamProvider___internal_tearOff(_createFn, allTransitiveDependencies, argument, debugGetCreateSourceHash, dependencies, from, $name, type$.dynamic);
    }, function(_createFn, allTransitiveDependencies, argument, debugGetCreateSourceHash, dependencies, from, $name) {
      return A.StreamProvider___internal_tearOff(_createFn, allTransitiveDependencies, argument, debugGetCreateSourceHash, dependencies, from, $name, type$.dynamic);
    }], 12, 1);
  })();
  (function inheritance() {
    var _mixin = hunkHelpers.mixin,
      _mixinHard = hunkHelpers.mixinHard,
      _inherit = hunkHelpers.inherit,
      _inheritMany = hunkHelpers.inheritMany;
    _inherit(A._SplayTreeMapNode, B._SplayTreeNode);
    _inherit(A._SplayTreeMap__SplayTree_MapMixin, B._SplayTree);
    _inherit(A.SplayTreeMap, A._SplayTreeMap__SplayTree_MapMixin);
    _inheritMany(B.EfficientLengthIterable, [A._SplayTreeKeyIterable, A._SplayTreeValueIterable, A._SplayTreeMapEntryIterable]);
    _inheritMany(B._SplayTreeIterator, [A._SplayTreeValueIterator, A._SplayTreeMapEntryIterator]);
    _inherit(A.RenderIndexedSemantics, B.RenderProxyBox);
    _inherit(A.SliverConstraints, B.Constraints);
    _inheritMany(B.Object, [A._SliverGeometry_Object_Diagnosticable, A.RenderSliverHelpers, A.KeepAliveParentDataMixin, A.RenderSliverWithKeepAliveMixin, A.SliverChildDelegate, A.Effect, A.AnimateManager, A.EffectEntry, A.ProviderFamilyBuilder, A.StreamProviderFamilyBuilder, A.Family, A._FamilyMixin]);
    _inherit(A.SliverGeometry, A._SliverGeometry_Object_Diagnosticable);
    _inherit(A.SliverHitTestResult, B.HitTestResult);
    _inherit(A.SliverHitTestEntry, B.HitTestEntry);
    _inheritMany(B.ParentData, [A.SliverLogicalParentData, A.SliverPhysicalParentData]);
    _inherit(A._SliverPhysicalContainerParentData_SliverPhysicalParentData_ContainerParentDataMixin, A.SliverPhysicalParentData);
    _inherit(A.SliverPhysicalContainerParentData, A._SliverPhysicalContainerParentData_SliverPhysicalParentData_ContainerParentDataMixin);
    _inherit(A.RenderSliver, B.RenderObject);
    _inheritMany(B.Closure, [A.RenderSliverHelpers_hitTestBoxChild_closure, A.RenderSliverMultiBoxAdaptor__createOrObtainChild_closure, A.RenderSliverMultiBoxAdaptor_collectGarbage_closure, A.RenderSliverMultiBoxAdaptor_collectGarbage__closure, A.RenderSliverEdgeInsetsPadding_performLayout_paintOffset, A.RenderSliverEdgeInsetsPadding_performLayout_cacheOffset, A.RenderViewportBase_visitChildrenForSemantics_closure, A.RenderViewportBase_hitTestChildren_closure, A._AutomaticKeepAliveState__addClient_closure, A._AutomaticKeepAliveState__getChildElement_closure, A.ScrollView_build_closure0, A.SliverMultiBoxAdaptorElement_performRebuild_processElement, A.FamilyBase_call_closure]);
    _inheritMany(A.RenderSliver, [A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin, A._RenderSliverEdgeInsetsPadding_RenderSliver_RenderObjectWithChildMixin]);
    _inherit(A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers, A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin);
    _inherit(A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers_RenderSliverWithKeepAliveMixin, A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers);
    _inherit(A.RenderSliverMultiBoxAdaptor, A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers_RenderSliverWithKeepAliveMixin);
    _inherit(A.RenderSliverList, A.RenderSliverMultiBoxAdaptor);
    _inheritMany(B.Closure0Args, [A.RenderSliverList_performLayout_advance, A._AutomaticKeepAliveState__createCallback_closure, A._AutomaticKeepAliveState__createCallback__closure, A._AutomaticKeepAliveState__createCallback__closure0, A._AutomaticKeepAliveState__createCallback___closure, A._SelectionKeepAliveState_listensTo_closure, A.SliverMultiBoxAdaptorElement_performRebuild_closure, A.SliverMultiBoxAdaptorElement_performRebuild_closure0, A.SliverMultiBoxAdaptorElement_createChild_closure, A.SliverMultiBoxAdaptorElement_removeChild_closure, A._AnimateState__restart_closure]);
    _inherit(A._SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin, A.SliverLogicalParentData);
    _inherit(A._SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin_KeepAliveParentDataMixin, A._SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin);
    _inherit(A.SliverMultiBoxAdaptorParentData, A._SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin_KeepAliveParentDataMixin);
    _inherit(A.RenderSliverEdgeInsetsPadding, A._RenderSliverEdgeInsetsPadding_RenderSliver_RenderObjectWithChildMixin);
    _inherit(A.RenderSliverPadding, A.RenderSliverEdgeInsetsPadding);
    _inherit(A.CacheExtentStyle, B._Enum);
    _inherit(A._RenderViewportBase_RenderBox_ContainerRenderObjectMixin, B.RenderBox);
    _inherit(A.RenderViewportBase, A._RenderViewportBase_RenderBox_ContainerRenderObjectMixin);
    _inherit(A.RenderViewport, A.RenderViewportBase);
    _inheritMany(B.StatefulWidget, [A.AutomaticKeepAlive, A._SelectionKeepAlive, A._Animate_StatefulWidget_AnimateManager]);
    _inheritMany(B.State, [A._AutomaticKeepAliveState, A.__SelectionKeepAliveState_State_AutomaticKeepAliveClientMixin, A.__AnimateState_State_SingleTickerProviderStateMixin]);
    _inheritMany(B.SingleChildRenderObjectWidget, [A.SliverPadding, A.IndexedSemantics]);
    _inherit(A._SaltedValueKey, B.ValueKey);
    _inherit(A.SliverChildBuilderDelegate, A.SliverChildDelegate);
    _inherit(A._SelectionKeepAliveState, A.__SelectionKeepAliveState_State_AutomaticKeepAliveClientMixin);
    _inherit(A.ScrollView, B.StatelessWidget);
    _inheritMany(B.Closure2Args, [A.ScrollView_build_closure, A.Animate_reparentTypes_closure, A.Animate_reparentTypes_closure0, A.Animate_reparentTypes_closure1, A.tasksForProjectProvider_closure]);
    _inherit(A.BoxScrollView, A.ScrollView);
    _inherit(A.ListView, A.BoxScrollView);
    _inherit(A.SliverWithKeepAliveWidget, B.RenderObjectWidget);
    _inherit(A.SliverMultiBoxAdaptorWidget, A.SliverWithKeepAliveWidget);
    _inherit(A.SliverList, A.SliverMultiBoxAdaptorWidget);
    _inherit(A.SliverMultiBoxAdaptorElement, B.RenderObjectElement);
    _inherit(A.KeepAlive, B.ParentDataWidget);
    _inherit(A.Viewport, B.MultiChildRenderObjectWidget);
    _inherit(A.__ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin, B.MultiChildRenderObjectElement);
    _inherit(A.__ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin_ViewportElementMixin, A.__ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin);
    _inherit(A._ViewportElement, A.__ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin_ViewportElementMixin);
    _inherit(A.Animate, A._Animate_StatefulWidget_AnimateManager);
    _inherit(A._AnimateState, A.__AnimateState_State_SingleTickerProviderStateMixin);
    _inheritMany(A.Effect, [A.FadeEffect, A.SlideEffect]);
    _inherit(A._FamilyBase_Family__FamilyMixin, A.Family);
    _inherit(A.FamilyBase, A._FamilyBase_Family__FamilyMixin);
    _inheritMany(A.FamilyBase, [A.ProviderFamily, A.StreamProviderFamily]);
    _mixin(A._SplayTreeMap__SplayTree_MapMixin, B.MapBase);
    _mixin(A._SliverGeometry_Object_Diagnosticable, B.Diagnosticable);
    _mixinHard(A._SliverPhysicalContainerParentData_SliverPhysicalParentData_ContainerParentDataMixin, B.ContainerParentDataMixin);
    _mixinHard(A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin, B.ContainerRenderObjectMixin);
    _mixin(A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers, A.RenderSliverHelpers);
    _mixin(A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers_RenderSliverWithKeepAliveMixin, A.RenderSliverWithKeepAliveMixin);
    _mixinHard(A._SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin, B.ContainerParentDataMixin);
    _mixin(A._SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin_KeepAliveParentDataMixin, A.KeepAliveParentDataMixin);
    _mixinHard(A._RenderSliverEdgeInsetsPadding_RenderSliver_RenderObjectWithChildMixin, B.RenderObjectWithChildMixin);
    _mixinHard(A._RenderViewportBase_RenderBox_ContainerRenderObjectMixin, B.ContainerRenderObjectMixin);
    _mixinHard(A.__SelectionKeepAliveState_State_AutomaticKeepAliveClientMixin, B.AutomaticKeepAliveClientMixin);
    _mixin(A.__ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin, B.NotifiableElementMixin);
    _mixin(A.__ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin_ViewportElementMixin, E.ViewportElementMixin);
    _mixin(A._Animate_StatefulWidget_AnimateManager, A.AnimateManager);
    _mixinHard(A.__AnimateState_State_SingleTickerProviderStateMixin, B.SingleTickerProviderStateMixin);
    _mixin(A._FamilyBase_Family__FamilyMixin, A._FamilyMixin);
  })();
  B._Universe_addRules(init.typeUniverse, JSON.parse('{"SplayTreeMap":{"MapBase":["1","2"],"_SplayTree":["1","_SplayTreeMapNode<1,2>"],"Map":["1","2"],"MapBase.V":"2","MapBase.K":"1","_SplayTree.K":"1"},"_SplayTreeKeyIterable":{"EfficientLengthIterable":["1"],"Iterable":["1"],"Iterable.E":"1"},"_SplayTreeValueIterable":{"EfficientLengthIterable":["2"],"Iterable":["2"],"Iterable.E":"2"},"_SplayTreeMapEntryIterable":{"EfficientLengthIterable":["MapEntry<1,2>"],"Iterable":["MapEntry<1,2>"],"Iterable.E":"MapEntry<1,2>"},"_SplayTreeValueIterator":{"_SplayTreeIterator":["1","_SplayTreeMapNode<1,2>","2"],"_SplayTreeIterator.T":"2"},"_SplayTreeMapEntryIterator":{"_SplayTreeIterator":["1","_SplayTreeMapNode<1,2>","MapEntry<1,2>"],"_SplayTreeIterator.T":"MapEntry<1,2>"},"RenderIndexedSemantics":{"RenderBox":[],"RenderObjectWithChildMixin":["RenderBox"],"RenderObject":[],"DiagnosticableTree":[],"HitTestTarget":[]},"SliverHitTestResult":{"HitTestResult":[]},"SliverPhysicalContainerParentData":{"SliverPhysicalParentData":[],"ContainerParentDataMixin":["RenderSliver"],"ParentData":[]},"RenderSliver":{"RenderObject":[],"DiagnosticableTree":[],"HitTestTarget":[]},"SliverHitTestEntry":{"HitTestEntry":["RenderSliver"]},"SliverLogicalParentData":{"ParentData":[]},"SliverPhysicalParentData":{"ParentData":[]},"RenderSliverList":{"RenderSliverMultiBoxAdaptor":[],"RenderSliver":[],"ContainerRenderObjectMixin":["RenderBox","SliverMultiBoxAdaptorParentData"],"RenderObject":[],"DiagnosticableTree":[],"HitTestTarget":[],"ContainerRenderObjectMixin.1":"SliverMultiBoxAdaptorParentData","ContainerRenderObjectMixin.0":"RenderBox"},"KeepAliveParentDataMixin":{"ParentData":[]},"SliverMultiBoxAdaptorParentData":{"ContainerParentDataMixin":["RenderBox"],"KeepAliveParentDataMixin":[],"ParentData":[]},"RenderSliverMultiBoxAdaptor":{"RenderSliver":[],"ContainerRenderObjectMixin":["RenderBox","SliverMultiBoxAdaptorParentData"],"RenderObject":[],"DiagnosticableTree":[],"HitTestTarget":[]},"RenderSliverEdgeInsetsPadding":{"RenderSliver":[],"RenderObjectWithChildMixin":["RenderSliver"],"RenderObject":[],"DiagnosticableTree":[],"HitTestTarget":[]},"RenderSliverPadding":{"RenderSliver":[],"RenderObjectWithChildMixin":["RenderSliver"],"RenderObject":[],"DiagnosticableTree":[],"HitTestTarget":[]},"RenderViewportBase":{"_RenderViewportBase_RenderBox_ContainerRenderObjectMixin":["1"],"RenderBox":[],"ContainerRenderObjectMixin":["RenderSliver","1"],"RenderAbstractViewport":[],"RenderObject":[],"DiagnosticableTree":[],"HitTestTarget":[]},"RenderViewport":{"_RenderViewportBase_RenderBox_ContainerRenderObjectMixin":["SliverPhysicalContainerParentData"],"RenderBox":[],"ContainerRenderObjectMixin":["RenderSliver","SliverPhysicalContainerParentData"],"RenderAbstractViewport":[],"RenderObject":[],"DiagnosticableTree":[],"HitTestTarget":[],"ContainerRenderObjectMixin.1":"SliverPhysicalContainerParentData","_RenderViewportBase_RenderBox_ContainerRenderObjectMixin.0":"SliverPhysicalContainerParentData","ContainerRenderObjectMixin.0":"RenderSliver"},"AutomaticKeepAlive":{"StatefulWidget":[],"Widget":[],"DiagnosticableTree":[]},"_AutomaticKeepAliveState":{"State":["AutomaticKeepAlive"]},"SliverPadding":{"SingleChildRenderObjectWidget":[],"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[]},"IndexedSemantics":{"SingleChildRenderObjectWidget":[],"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[]},"_SelectionKeepAlive":{"StatefulWidget":[],"Widget":[],"DiagnosticableTree":[]},"_SaltedValueKey":{"ValueKey":["Key"],"Key":[],"ValueKey.T":"Key"},"_SelectionKeepAliveState":{"State":["_SelectionKeepAlive"]},"ScrollView":{"StatelessWidget":[],"Widget":[],"DiagnosticableTree":[]},"BoxScrollView":{"StatelessWidget":[],"Widget":[],"DiagnosticableTree":[]},"ListView":{"StatelessWidget":[],"Widget":[],"DiagnosticableTree":[]},"SliverWithKeepAliveWidget":{"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[]},"SliverMultiBoxAdaptorWidget":{"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[]},"SliverList":{"SliverMultiBoxAdaptorWidget":[],"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[]},"SliverMultiBoxAdaptorElement":{"RenderObjectElement":[],"Element":[],"DiagnosticableTree":[],"BuildContext":[]},"KeepAlive":{"ParentDataWidget":["KeepAliveParentDataMixin"],"ProxyWidget":[],"Widget":[],"DiagnosticableTree":[],"ParentDataWidget.T":"KeepAliveParentDataMixin"},"Viewport":{"MultiChildRenderObjectWidget":[],"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[]},"_ViewportElement":{"RenderObjectElement":[],"Element":[],"DiagnosticableTree":[],"BuildContext":[]},"Animate":{"StatefulWidget":[],"Widget":[],"DiagnosticableTree":[],"AnimateManager":["Animate"]},"_AnimateState":{"State":["Animate"]},"FadeEffect":{"Effect":["double"],"Effect.T":"double"},"SlideEffect":{"Effect":["Offset"],"Effect.T":"Offset"},"Family":{"ProviderOrFamily":[],"Override":[]},"FamilyBase":{"_FamilyMixin":["2","3","5"],"Family":["2"],"ProviderOrFamily":[],"Override":[]},"ProviderFamily":{"FamilyBase":["ProviderRef<1>","1","2","1","Provider<1>"],"_FamilyMixin":["1","2","Provider<1>"],"Family":["1"],"ProviderOrFamily":[],"Override":[],"_FamilyMixin.1":"2","FamilyBase.3":"1","FamilyBase.0":"ProviderRef<1>"},"StreamProviderFamily":{"FamilyBase":["StreamProviderRef<1>","AsyncValue<1>","2","Stream<1>","StreamProvider<1>"],"_FamilyMixin":["AsyncValue<1>","2","StreamProvider<1>"],"Family":["AsyncValue<1>"],"ProviderOrFamily":[],"Override":[],"_FamilyMixin.1":"2","FamilyBase.3":"Stream<1>","FamilyBase.0":"StreamProviderRef<1>"}}'));
  B._Universe_addErasedTypes(init.typeUniverse, JSON.parse('{"_SplayTreeMap__SplayTree_MapMixin":2,"RenderViewportBase":1,"Family":1,"_FamilyBase_Family__FamilyMixin":5}'));
  var type$ = (function rtii() {
    var findType = B.findType;
    return {
      Animation_double: findType("Animation<double>"),
      Directionality: findType("Directionality"),
      Element: findType("Element"),
      Expanded: findType("Expanded"),
      Flexible: findType("Flexible"),
      JSArray_DiagnosticsNode: findType("JSArray<DiagnosticsNode>"),
      JSArray_EffectEntry: findType("JSArray<EffectEntry>"),
      JSArray_RenderSliver: findType("JSArray<RenderSliver>"),
      JSArray_String: findType("JSArray<String>"),
      JSArray_Widget: findType("JSArray<Widget>"),
      KeepAliveParentDataMixin: findType("KeepAliveParentDataMixin"),
      Listenable: findType("Listenable"),
      NotificationListener_KeepAliveNotification: findType("NotificationListener<KeepAliveNotification>"),
      NotificationListener_ScrollUpdateNotification: findType("NotificationListener<ScrollUpdateNotification>"),
      ParentDataWidget_KeepAliveParentDataMixin: findType("ParentDataWidget<KeepAliveParentDataMixin>"),
      Positioned: findType("Positioned"),
      RenderBox: findType("RenderBox"),
      RenderSliver: findType("RenderSliver"),
      RenderSliverMultiBoxAdaptor: findType("RenderSliverMultiBoxAdaptor"),
      RenderViewport: findType("RenderViewport"),
      Selectable: findType("Selectable0"),
      SliverConstraints: findType("SliverConstraints"),
      SliverMultiBoxAdaptorElement: findType("SliverMultiBoxAdaptorElement"),
      SliverMultiBoxAdaptorParentData: findType("SliverMultiBoxAdaptorParentData"),
      SliverMultiBoxAdaptorWidget: findType("SliverMultiBoxAdaptorWidget"),
      SliverPhysicalParentData: findType("SliverPhysicalParentData"),
      TaskRepository: findType("TaskRepository"),
      Viewport: findType("Viewport"),
      double: findType("double"),
      dynamic: findType("@"),
      int: findType("int"),
      nullable_Element: findType("Element?"),
      nullable_ParentDataElement_KeepAliveParentDataMixin: findType("ParentDataElement<KeepAliveParentDataMixin>?"),
      nullable_RenderBox: findType("RenderBox?"),
      nullable_RenderSliver: findType("RenderSliver?"),
      nullable_SliverMultiBoxAdaptorParentData: findType("SliverMultiBoxAdaptorParentData?"),
      void: findType("~"),
      void_Function: findType("~()")
    };
  })();
  (function constants() {
    D.BouncingScrollPhysics_ScrollDecelerationRate_0_null = new B.BouncingScrollPhysics(C.ScrollDecelerationRate_0, null);
    D.C_ProviderFamilyBuilder = new A.ProviderFamilyBuilder();
    D.C_StreamProviderFamilyBuilder = new A.StreamProviderFamilyBuilder();
    D.CacheExtentStyle_0 = new A.CacheExtentStyle(0, "pixel");
    D.SliverGeometry_QEo = new A.SliverGeometry(0, 0, 0, 0, 0, 0, false, false, null, 0);
    D.Type_Expanded_yLA = B.typeLiteral("Expanded");
    D.Type_Flexible_gf0 = B.typeLiteral("Flexible");
    D.Type_Positioned_Uad = B.typeLiteral("Positioned");
  })();
  (function lazyInitializers() {
    var _lazy = hunkHelpers.lazy,
      _lazyFinal = hunkHelpers.lazyFinal;
    _lazy($, "Animate_reparentTypes", "$get$Animate_reparentTypes", () => B.LinkedHashMap_LinkedHashMap$_literal([D.Type_Flexible_gf0, new A.Animate_reparentTypes_closure(), D.Type_Positioned_Uad, new A.Animate_reparentTypes_closure0(), D.Type_Expanded_yLA, new A.Animate_reparentTypes_closure1()], B.findType("Type"), B.findType("Widget(Widget,Widget)")));
    _lazyFinal($, "tasksForProjectProvider", "$get$tasksForProjectProvider", () => D.C_StreamProviderFamilyBuilder.call$2$1(new A.tasksForProjectProvider_closure(), B.findType("List<Task>"), B.findType("String")));
  })();
};
;
((d, h) => {
  d[h] = d.current;
  d.eventLog.push({p: "main.dart.js_2", e: "endPart", h: h});
})($__dart_deferred_initializers__, "98w8A0lTCmr+fkLzskYZi7uBB9o=");
;