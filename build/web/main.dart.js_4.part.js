// Generated by dart2js (NullSafetyMode.sound, trust primitives, omit checks, lax runtime type, csp, intern-composite-values), the Dart to JavaScript compiler version: 3.7.2.
((s, d, e) => {
  s[d] = s[d] || {};
  s[d][e] = s[d][e] || [];
  s[d][e].push({p: "main.dart.js_4", e: "beginPart"});
})(self, "$__dart_deferred_initializers__", "eventLog");
$__dart_deferred_initializers__.current = function(hunkHelpers, init, holdersList, $) {
  var J, A, C,
  B = {RevealedOffset: function RevealedOffset(t0, t1) {
      this.offset = t0;
      this.rect = t1;
    },
    Scrollable$(axisDirection, clipBehavior, controller, dragStartBehavior, excludeFromSemantics, hitTestBehavior, key, physics, restorationId, scrollBehavior, semanticChildCount, viewportBuilder) {
      return new B.Scrollable(axisDirection, controller, physics, viewportBuilder, excludeFromSemantics, hitTestBehavior, semanticChildCount, dragStartBehavior, restorationId, scrollBehavior, clipBehavior, key);
    },
    _getDeltaToScrollOrigin(scrollableState) {
      var t1;
      switch (scrollableState._widget.axisDirection.index) {
        case 0:
          t1 = scrollableState._scrollable$_position._pixels;
          t1.toString;
          t1 = new A.Offset(0, -t1);
          break;
        case 2:
          t1 = scrollableState._scrollable$_position._pixels;
          t1.toString;
          t1 = new A.Offset(0, t1);
          break;
        case 3:
          t1 = scrollableState._scrollable$_position._pixels;
          t1.toString;
          t1 = new A.Offset(-t1, 0);
          break;
        case 1:
          t1 = scrollableState._scrollable$_position._pixels;
          t1.toString;
          t1 = new A.Offset(t1, 0);
          break;
        default:
          t1 = null;
      }
      return t1;
    },
    _ScrollableState_State_TickerProviderStateMixin_RestorationMixin_dispose_closure: function _ScrollableState_State_TickerProviderStateMixin_RestorationMixin_dispose_closure() {
    },
    Scrollable: function Scrollable(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) {
      var _ = this;
      _.axisDirection = t0;
      _.controller = t1;
      _.physics = t2;
      _.viewportBuilder = t3;
      _.excludeFromSemantics = t4;
      _.hitTestBehavior = t5;
      _.semanticChildCount = t6;
      _.dragStartBehavior = t7;
      _.restorationId = t8;
      _.scrollBehavior = t9;
      _.clipBehavior = t10;
      _.key = t11;
    },
    _ScrollableScope: function _ScrollableScope(t0, t1, t2, t3) {
      var _ = this;
      _.scrollable = t0;
      _.position = t1;
      _.child = t2;
      _.key = t3;
    },
    ScrollableState: function ScrollableState(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) {
      var _ = this;
      _._physics = _._scrollable$_position = null;
      _.__ScrollableState__devicePixelRatio_A = $;
      _._persistedScrollOffset = t0;
      _.__ScrollableState__configuration_A = $;
      _._mediaQueryGestureSettings = _._fallbackScrollController = null;
      _._scrollSemanticsKey = t1;
      _._gestureDetectorKey = t2;
      _._ignorePointerKey = t3;
      _._gestureRecognizers = t4;
      _._shouldIgnorePointer = false;
      _._hold = _._scrollable$_drag = _._scrollable$_lastAxisDirection = _._lastCanDrag = null;
      _.RestorationMixin__bucket = t5;
      _.RestorationMixin__properties = t6;
      _.RestorationMixin__debugPropertiesWaitingForReregistration = t7;
      _.RestorationMixin__firstRestorePending = t8;
      _.RestorationMixin__currentParent = t9;
      _.TickerProviderStateMixin__tickers = t10;
      _.TickerProviderStateMixin__tickerModeNotifier = t11;
      _._framework$_element = _._widget = null;
    },
    ScrollableState_setCanDrag_closure: function ScrollableState_setCanDrag_closure(t0) {
      this.$this = t0;
    },
    ScrollableState_setCanDrag_closure0: function ScrollableState_setCanDrag_closure0(t0) {
      this.$this = t0;
    },
    ScrollableState_setCanDrag_closure1: function ScrollableState_setCanDrag_closure1(t0) {
      this.$this = t0;
    },
    ScrollableState_setCanDrag_closure2: function ScrollableState_setCanDrag_closure2(t0) {
      this.$this = t0;
    },
    _ScrollableSelectionHandler: function _ScrollableSelectionHandler(t0, t1, t2, t3, t4) {
      var _ = this;
      _.state = t0;
      _.position = t1;
      _.child = t2;
      _.registrar = t3;
      _.key = t4;
    },
    _ScrollableSelectionHandlerState: function _ScrollableSelectionHandlerState() {
      this.___ScrollableSelectionHandlerState__selectionDelegate_A = $;
      this._framework$_element = this._widget = null;
    },
    _ScrollableSelectionContainerDelegate: function _ScrollableSelectionContainerDelegate(t0, t1, t2, t3, t4, t5, t6, t7, t8) {
      var _ = this;
      _.state = t0;
      _._autoScroller = t1;
      _._scheduledLayoutChange = false;
      _._currentDragEndRelatedToOrigin = _._currentDragStartRelatedToOrigin = null;
      _._selectionStartsInScrollable = false;
      _._scrollable$_position = t2;
      _._selectableStartEdgeUpdateRecords = t3;
      _._selectableEndEdgeUpdateRecords = t4;
      _.selectables = t5;
      _.currentSelectionStartIndex = _.currentSelectionEndIndex = -1;
      _._endHandleLayerOwner = _._endHandleLayer = _._startHandleLayerOwner = _._startHandleLayer = null;
      _._selectionInProgress = _._scheduledSelectableUpdate = _._isHandlingSelectionEvent = false;
      _._additions = t6;
      _._extendSelectionInProgress = false;
      _._selectionGeometry = t7;
      _.ChangeNotifier__count = 0;
      _.ChangeNotifier__listeners = t8;
      _.ChangeNotifier__reentrantlyRemovedListeners = _.ChangeNotifier__notificationCallStackDepth = 0;
      _._selectionContainerContext = null;
    },
    _ScrollableSelectionContainerDelegate__scheduleLayoutChange_closure: function _ScrollableSelectionContainerDelegate__scheduleLayoutChange_closure(t0) {
      this.$this = t0;
    },
    _ScrollableSelectionContainerDelegate_didChangeSelectables_closure: function _ScrollableSelectionContainerDelegate_didChangeSelectables_closure(t0) {
      this.selectableSet = t0;
    },
    _ScrollableSelectionContainerDelegate_didChangeSelectables_closure0: function _ScrollableSelectionContainerDelegate_didChangeSelectables_closure0(t0) {
      this.selectableSet = t0;
    },
    _ScrollSemantics: function _ScrollSemantics(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.position = t0;
      _.allowImplicitScrolling = t1;
      _.semanticChildCount = t2;
      _.axis = t3;
      _.child = t4;
      _.key = t5;
    },
    _RenderScrollSemantics: function _RenderScrollSemantics(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._scrollable$_position = t0;
      _._allowImplicitScrolling = t1;
      _.axis = t2;
      _._semanticChildCount = t3;
      _._innerNode = null;
      _.RenderObjectWithChildMixin__child = t4;
      _._layoutCacheStorage = t5;
      _.parentData = _._box$_size = null;
      _._depth = 0;
      _._object$_owner = _._object$_parent = null;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _.__RenderObject__wasRepaintBoundary_A = $;
      _._layerHandle = t6;
      _._needsCompositingBitsUpdate = false;
      _.__RenderObject__needsCompositing_A = $;
      _._needsPaint = true;
      _._needsCompositedLayerUpdate = false;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
    },
    _RestorableScrollOffset: function _RestorableScrollOffset(t0) {
      var _ = this;
      _._restoration_properties$_value = null;
      _._restoration0$_disposed = false;
      _._restoration0$_owner = _._restoration0$_restorationId = null;
      _.ChangeNotifier__count = 0;
      _.ChangeNotifier__listeners = t0;
      _.ChangeNotifier__reentrantlyRemovedListeners = _.ChangeNotifier__notificationCallStackDepth = 0;
    },
    _ScrollableState_State_TickerProviderStateMixin: function _ScrollableState_State_TickerProviderStateMixin() {
    },
    _ScrollableState_State_TickerProviderStateMixin_RestorationMixin: function _ScrollableState_State_TickerProviderStateMixin_RestorationMixin() {
    },
    ScrollableDetails: function ScrollableDetails(t0, t1, t2) {
      this.direction = t0;
      this.controller = t1;
      this.decorationClipBehavior = t2;
    },
    ScrollableDetails_toString_addIfNonNull: function ScrollableDetails_toString_addIfNonNull(t0) {
      this.description = t0;
    },
    EdgeDraggingAutoScroller: function EdgeDraggingAutoScroller(t0, t1) {
      var _ = this;
      _.scrollable = t0;
      _.velocityScalar = t1;
      _.__EdgeDraggingAutoScroller__dragTargetRelatedToScrollOrigin_A = $;
      _._scrolling = false;
    },
    flipAxis(direction) {
      var t1;
      switch (direction.index) {
        case 0:
          t1 = C.Axis_1;
          break;
        case 1:
          t1 = C.Axis_0;
          break;
        default:
          t1 = null;
      }
      return t1;
    }
  },
  D;
  J = holdersList[1];
  A = holdersList[0];
  C = holdersList[2];
  B = hunkHelpers.updateHolder(holdersList[12], B);
  D = holdersList[19];
  B.RevealedOffset.prototype = {
    toString$0(_) {
      return "RevealedOffset(offset: " + A.S(this.offset) + ", rect: " + this.rect.toString$0(0) + ")";
    }
  };
  B.Scrollable.prototype = {
    createState$0() {
      var _null = null,
        t1 = type$.LabeledGlobalKey_State_StatefulWidget;
      return new B.ScrollableState(new B._RestorableScrollOffset($.$get$ChangeNotifier__emptyListeners()), new A.LabeledGlobalKey(_null, t1), new A.LabeledGlobalKey(_null, type$.LabeledGlobalKey_RawGestureDetectorState), new A.LabeledGlobalKey(_null, t1), C.Map_empty4, _null, A.LinkedHashMap_LinkedHashMap$_empty(type$.RestorableProperty_nullable_Object, type$.void_Function), _null, true, _null, _null, _null);
    },
    viewportBuilder$2(arg0, arg1) {
      return this.viewportBuilder.call$2(arg0, arg1);
    }
  };
  B._ScrollableScope.prototype = {
    updateShouldNotify$1(old) {
      return this.position !== old.position;
    }
  };
  B.ScrollableState.prototype = {
    get$position() {
      var t1 = this._scrollable$_position;
      t1.toString;
      return t1;
    },
    get$resolvedPhysics() {
      return this._physics;
    },
    get$deltaToScrollOrigin() {
      var t1, _this = this;
      switch (_this._widget.axisDirection.index) {
        case 0:
          t1 = _this._scrollable$_position._pixels;
          t1.toString;
          t1 = new A.Offset(0, -t1);
          break;
        case 2:
          t1 = _this._scrollable$_position._pixels;
          t1.toString;
          t1 = new A.Offset(0, t1);
          break;
        case 3:
          t1 = _this._scrollable$_position._pixels;
          t1.toString;
          t1 = new A.Offset(-t1, 0);
          break;
        case 1:
          t1 = _this._scrollable$_position._pixels;
          t1.toString;
          t1 = new A.Offset(t1, 0);
          break;
        default:
          t1 = null;
      }
      return t1;
    },
    get$_effectiveScrollController() {
      var t1 = this._widget.controller;
      if (t1 == null) {
        t1 = this._fallbackScrollController;
        t1.toString;
      }
      return t1;
    },
    get$axisDirection() {
      return this._widget.axisDirection;
    },
    get$vsync() {
      return this;
    },
    get$devicePixelRatio() {
      var t1 = this.__ScrollableState__devicePixelRatio_A;
      t1 === $ && A.throwUnnamedLateFieldNI();
      return t1;
    },
    get$notificationContext() {
      return $.WidgetsBinding__instance.WidgetsBinding__buildOwner._globalKeyRegistry.$index(0, this._gestureDetectorKey);
    },
    get$storageContext() {
      var t1 = this._framework$_element;
      t1.toString;
      return t1;
    },
    get$restorationId() {
      return this._widget.restorationId;
    },
    _updatePosition$0() {
      var physicsFromWidget, t2, oldPosition, _this = this, _null = null,
        t1 = _this._widget.scrollBehavior;
      if (t1 == null) {
        t1 = _this._framework$_element;
        t1.toString;
        t1 = A.ScrollConfiguration_of(t1);
      }
      _this.__ScrollableState__configuration_A = t1;
      t1 = _this._widget;
      physicsFromWidget = t1.physics;
      if (physicsFromWidget == null) {
        t1 = t1.scrollBehavior;
        if (t1 == null)
          physicsFromWidget = _null;
        else {
          t2 = _this._framework$_element;
          t2.toString;
          t2 = t1.getScrollPhysics$1(t2);
          physicsFromWidget = t2;
        }
      }
      t1 = _this.__ScrollableState__configuration_A;
      t2 = _this._framework$_element;
      t2.toString;
      t2 = t1.getScrollPhysics$1(t2);
      _this._physics = t2;
      t1 = physicsFromWidget == null ? _null : physicsFromWidget.applyTo$1(t2);
      _this._physics = t1 == null ? _this._physics : t1;
      oldPosition = _this._scrollable$_position;
      if (oldPosition != null) {
        _this.get$_effectiveScrollController().detach$1(oldPosition);
        A.scheduleMicrotask(oldPosition.get$dispose());
      }
      _this.get$_effectiveScrollController();
      t1 = _this._physics;
      t1.toString;
      t2 = $.$get$ChangeNotifier__emptyListeners();
      t2 = new A.ScrollPositionWithSingleContext(C.ScrollDirection_0, t1, _this, true, _null, new A.ValueNotifier(false, t2), t2);
      t2.ScrollPosition$5$context$debugLabel$keepScrollOffset$oldPosition$physics(_this, _null, true, oldPosition, t1);
      t1 = t2._pixels;
      if (t1 == null)
        t2._pixels = 0;
      if (t2._activity == null)
        t2.beginActivity$1(new A.IdleScrollActivity(t2));
      _this._scrollable$_position = t2;
      t1 = _this.get$_effectiveScrollController();
      t2 = _this._scrollable$_position;
      t2.toString;
      t1.attach$1(t2);
    },
    restoreState$2(oldBucket, initialRestore) {
      var t2, t3, t4,
        t1 = this._persistedScrollOffset;
      this.registerForRestoration$2(t1, "offset");
      t2 = t1._restoration_properties$_value;
      t3 = t2 == null;
      if ((t3 ? A._instanceType(t1)._eval$1("RestorableValue.T")._as(t2) : t2) != null) {
        t4 = this._scrollable$_position;
        t4.toString;
        t1 = t3 ? A._instanceType(t1)._eval$1("RestorableValue.T")._as(t2) : t2;
        t1.toString;
        if (initialRestore)
          t4._pixels = t1;
        else
          t4.jumpTo$1(t1);
      }
    },
    saveOffset$1(offset) {
      var t1;
      this._persistedScrollOffset.set$value(offset);
      t1 = $.ServicesBinding__instance.ServicesBinding___ServicesBinding__restorationManager_A;
      t1 === $ && A.throwUnnamedLateFieldNI();
      t1.flushData$0();
    },
    initState$0() {
      if (this._widget.controller == null)
        this._fallbackScrollController = A.ScrollController$();
      this.super$State$initState();
    },
    didChangeDependencies$0() {
      var _this = this,
        t1 = _this._framework$_element;
      t1.toString;
      t1 = A.MediaQuery__maybeOf(t1, C._MediaQueryAspect_18);
      _this._mediaQueryGestureSettings = t1 == null ? null : t1.gestureSettings;
      t1 = _this._framework$_element;
      t1.toString;
      t1 = A.MediaQuery__maybeOf(t1, C._MediaQueryAspect_2);
      t1 = t1 == null ? null : t1.devicePixelRatio;
      if (t1 == null) {
        t1 = _this._framework$_element;
        t1.toString;
        A.View_maybeOf(t1).toString;
        t1 = $.$get$EngineFlutterDisplay__instance()._debugDevicePixelRatioOverride;
        if (t1 == null) {
          t1 = self.window.devicePixelRatio;
          if (t1 === 0)
            t1 = 1;
        }
      }
      _this.__ScrollableState__devicePixelRatio_A = t1;
      _this._updatePosition$0();
      _this.super$_ScrollableState_State_TickerProviderStateMixin_RestorationMixin$didChangeDependencies();
    },
    _shouldUpdatePosition$1(oldWidget) {
      var newPhysics, oldPhysics, _this = this, _null = null,
        t1 = _this._widget.scrollBehavior,
        t2 = t1 == null,
        t3 = oldWidget.scrollBehavior,
        t4 = t3 == null;
      if (t2 !== t4)
        return true;
      if (!t2)
        if (!t4) {
          t2 = true;
          if (A.getRuntimeTypeOfDartObject(t3.delegate) === A.getRuntimeTypeOfDartObject(t1.delegate))
            if (t3.scrollbars === t1.scrollbars)
              if (t3.overscroll === t1.overscroll)
                if (A.setEquals(t3.get$dragDevices(), t1.get$dragDevices())) {
                  t1 = A.setEquals(t3.get$pointerAxisModifiers(), t1.get$pointerAxisModifiers());
                  t1 = !t1;
                } else
                  t1 = t2;
              else
                t1 = t2;
            else
              t1 = t2;
          else
            t1 = t2;
        } else
          t1 = false;
      else
        t1 = false;
      if (t1)
        return true;
      t1 = _this._widget;
      newPhysics = t1.physics;
      if (newPhysics == null) {
        t1 = t1.scrollBehavior;
        if (t1 == null)
          newPhysics = _null;
        else {
          t2 = _this._framework$_element;
          t2.toString;
          t2 = t1.getScrollPhysics$1(t2);
          newPhysics = t2;
        }
      }
      oldPhysics = oldWidget.physics;
      if (oldPhysics == null)
        if (t4)
          oldPhysics = _null;
        else {
          t1 = _this._framework$_element;
          t1.toString;
          t1 = t3.getScrollPhysics$1(t1);
          oldPhysics = t1;
        }
      do {
        t1 = newPhysics == null;
        t2 = t1 ? _null : A.getRuntimeTypeOfDartObject(newPhysics);
        t3 = oldPhysics == null;
        if (t2 != (t3 ? _null : A.getRuntimeTypeOfDartObject(oldPhysics)))
          return true;
        newPhysics = t1 ? _null : newPhysics.parent;
        oldPhysics = t3 ? _null : oldPhysics.parent;
      } while (newPhysics != null || oldPhysics != null);
      t1 = _this._widget.controller;
      t1 = t1 == null ? _null : A.getRuntimeTypeOfDartObject(t1);
      t2 = oldWidget.controller;
      return t1 != (t2 == null ? _null : A.getRuntimeTypeOfDartObject(t2));
    },
    didUpdateWidget$1(oldWidget) {
      var t1, t2, _this = this;
      _this.super$_ScrollableState_State_TickerProviderStateMixin_RestorationMixin$didUpdateWidget(oldWidget);
      t1 = oldWidget.controller;
      if (_this._widget.controller != t1) {
        if (t1 == null) {
          t1 = _this._fallbackScrollController;
          t1.toString;
          t2 = _this._scrollable$_position;
          t2.toString;
          t1.detach$1(t2);
          _this._fallbackScrollController.dispose$0();
          _this._fallbackScrollController = null;
        } else {
          t2 = _this._scrollable$_position;
          t2.toString;
          t1.detach$1(t2);
          if (_this._widget.controller == null)
            _this._fallbackScrollController = A.ScrollController$();
        }
        t1 = _this.get$_effectiveScrollController();
        t2 = _this._scrollable$_position;
        t2.toString;
        t1.attach$1(t2);
      }
      if (_this._shouldUpdatePosition$1(oldWidget))
        _this._updatePosition$0();
    },
    dispose$0() {
      var t2, _this = this,
        t1 = _this._widget.controller;
      if (t1 != null) {
        t2 = _this._scrollable$_position;
        t2.toString;
        t1.detach$1(t2);
      } else {
        t1 = _this._fallbackScrollController;
        if (t1 != null) {
          t2 = _this._scrollable$_position;
          t2.toString;
          t1.detach$1(t2);
        }
        t1 = _this._fallbackScrollController;
        if (t1 != null)
          t1.dispose$0();
      }
      _this._scrollable$_position.dispose$0();
      _this._persistedScrollOffset.dispose$0();
      _this.super$_ScrollableState_State_TickerProviderStateMixin_RestorationMixin$dispose();
    },
    setSemanticsActions$1(actions) {
      var t1 = this._gestureDetectorKey;
      if (t1.get$currentState() != null)
        t1.get$currentState().replaceSemanticsActions$1(actions);
    },
    setCanDrag$1(value) {
      var t1, t2, _this = this;
      if (value === _this._lastCanDrag)
        t1 = !value || A.axisDirectionToAxis(_this._widget.axisDirection) === _this._scrollable$_lastAxisDirection;
      else
        t1 = false;
      if (t1)
        return;
      if (!value) {
        _this._gestureRecognizers = C.Map_empty4;
        _this._scrollable$_handleDragCancel$0();
      } else {
        switch (A.axisDirectionToAxis(_this._widget.axisDirection).index) {
          case 1:
            _this._gestureRecognizers = A.LinkedHashMap_LinkedHashMap$_literal([C.Type_yGg, new A.GestureRecognizerFactoryWithHandlers(new B.ScrollableState_setCanDrag_closure(_this), new B.ScrollableState_setCanDrag_closure0(_this), type$.GestureRecognizerFactoryWithHandlers_VerticalDragGestureRecognizer)], type$.Type, type$.GestureRecognizerFactory_GestureRecognizer);
            break;
          case 0:
            _this._gestureRecognizers = A.LinkedHashMap_LinkedHashMap$_literal([C.Type_btT, new A.GestureRecognizerFactoryWithHandlers(new B.ScrollableState_setCanDrag_closure1(_this), new B.ScrollableState_setCanDrag_closure2(_this), type$.GestureRecognizerFactoryWithHandlers_HorizontalDragGestureRecognizer)], type$.Type, type$.GestureRecognizerFactory_GestureRecognizer);
            break;
        }
        value = true;
      }
      _this._lastCanDrag = value;
      _this._scrollable$_lastAxisDirection = A.axisDirectionToAxis(_this._widget.axisDirection);
      t1 = _this._gestureDetectorKey;
      if (t1.get$currentState() != null) {
        t1 = t1.get$currentState();
        t1._syncAll$1(_this._gestureRecognizers);
        if (!t1._widget.excludeFromSemantics) {
          t2 = t1._framework$_element.get$renderObject();
          t2.toString;
          type$.RenderSemanticsGestureHandler._as(t2);
          t1._gesture_detector$_semantics.assignSemantics$1(t2);
        }
      }
    },
    setIgnorePointer$1(value) {
      var t1, _this = this;
      if (_this._shouldIgnorePointer === value)
        return;
      _this._shouldIgnorePointer = value;
      t1 = _this._ignorePointerKey;
      if ($.WidgetsBinding__instance.WidgetsBinding__buildOwner._globalKeyRegistry.$index(0, t1) != null) {
        t1 = $.WidgetsBinding__instance.WidgetsBinding__buildOwner._globalKeyRegistry.$index(0, t1).get$renderObject();
        t1.toString;
        type$.RenderIgnorePointer._as(t1).set$ignoring(_this._shouldIgnorePointer);
      }
    },
    _handleDragDown$1(details) {
      this._hold = this._scrollable$_position.hold$1(this.get$_disposeHold());
    },
    _scrollable$_handleDragStart$1(details) {
      var _this = this;
      _this._scrollable$_drag = _this._scrollable$_position.drag$2(details, _this.get$_disposeDrag());
      if (_this._hold != null)
        _this._hold = null;
    },
    _scrollable$_handleDragUpdate$1(details) {
      var t1 = this._scrollable$_drag;
      if (t1 != null)
        t1.update$1(details);
    },
    _scrollable$_handleDragEnd$1(details) {
      var t1 = this._scrollable$_drag;
      if (t1 != null)
        t1.end$1(details);
    },
    _scrollable$_handleDragCancel$0() {
      if ($.WidgetsBinding__instance.WidgetsBinding__buildOwner._globalKeyRegistry.$index(0, this._gestureDetectorKey) == null)
        return;
      var t1 = this._hold;
      if (t1 != null)
        t1._scroll_activity$_delegate.goBallistic$1(0);
      t1 = this._scrollable$_drag;
      if (t1 != null)
        t1._scroll_activity$_delegate.goBallistic$1(0);
    },
    _disposeHold$0() {
      this._hold = null;
    },
    _disposeDrag$0() {
      this._scrollable$_drag = null;
    },
    _scrollable$_targetScrollOffsetForPointerScroll$1(delta) {
      var t3,
        t1 = this._scrollable$_position,
        t2 = t1._pixels;
      t2.toString;
      t3 = t1._scroll_position$_minScrollExtent;
      t3.toString;
      t3 = Math.max(t2 + delta, t3);
      t1 = t1._scroll_position$_maxScrollExtent;
      t1.toString;
      return Math.min(t3, t1);
    },
    _scrollable$_pointerSignalEventDelta$1($event) {
      var t2, pressed, flipAxes,
        t1 = $.ServicesBinding__instance.ServicesBinding___ServicesBinding__keyboard_F;
      t1 === $ && A.throwUnnamedLateFieldNI();
      t1 = t1._pressedKeys;
      t2 = A._instanceType(t1)._eval$1("LinkedHashMapValuesIterable<2>");
      pressed = A.LinkedHashSet_LinkedHashSet$of(new A.LinkedHashMapValuesIterable(t1, t2), t2._eval$1("Iterable.E"));
      t1 = this.__ScrollableState__configuration_A;
      t1 === $ && A.throwUnnamedLateFieldNI();
      t1 = t1.get$pointerAxisModifiers();
      flipAxes = pressed.any$1(0, t1.get$contains(t1)) && $event.get$kind() === C.PointerDeviceKind_1;
      t1 = this._widget;
      switch ((flipAxes ? B.flipAxis(A.axisDirectionToAxis(t1.axisDirection)) : A.axisDirectionToAxis(t1.axisDirection)).index) {
        case 0:
          t1 = $event.get$scrollDelta()._dx;
          break;
        case 1:
          t1 = $event.get$scrollDelta()._dy;
          break;
        default:
          t1 = null;
      }
      return A.axisDirectionIsReversed(this._widget.axisDirection) ? -t1 : t1;
    },
    _receivedPointerSignal$1($event) {
      var t1, t2, delta, targetScrollOffset, _this = this;
      if (type$.PointerScrollEvent._is($event) && _this._scrollable$_position != null) {
        t1 = _this._physics;
        if (t1 != null) {
          t2 = _this._scrollable$_position;
          t2.toString;
          t2 = !t1.shouldAcceptUserOffset$1(t2);
          t1 = t2;
        } else
          t1 = false;
        if (t1) {
          $event.respond$1$allowPlatformDefault(true);
          return;
        }
        delta = _this._scrollable$_pointerSignalEventDelta$1($event);
        targetScrollOffset = _this._scrollable$_targetScrollOffsetForPointerScroll$1(delta);
        if (delta !== 0) {
          t1 = _this._scrollable$_position._pixels;
          t1.toString;
          t1 = targetScrollOffset !== t1;
        } else
          t1 = false;
        if (t1) {
          $.GestureBinding__instance.GestureBinding_pointerSignalResolver.register$2($event, _this.get$_scrollable$_handlePointerScroll());
          return;
        }
        $event.respond$1$allowPlatformDefault(true);
      } else if (type$.PointerScrollInertiaCancelEvent._is($event))
        _this._scrollable$_position.pointerScroll$1(0);
    },
    _scrollable$_handlePointerScroll$1($event) {
      var t1, _this = this,
        delta = _this._scrollable$_pointerSignalEventDelta$1($event),
        targetScrollOffset = _this._scrollable$_targetScrollOffsetForPointerScroll$1(delta);
      if (delta !== 0) {
        t1 = _this._scrollable$_position._pixels;
        t1.toString;
        t1 = targetScrollOffset !== t1;
      } else
        t1 = false;
      if (t1)
        _this._scrollable$_position.pointerScroll$1(delta);
    },
    _handleScrollMetricsNotification$1(notification) {
      var t1, scrollSemanticsRenderObject;
      if (notification.ViewportNotificationMixin__depth === 0) {
        t1 = $.WidgetsBinding__instance.WidgetsBinding__buildOwner._globalKeyRegistry.$index(0, this._scrollSemanticsKey);
        scrollSemanticsRenderObject = t1 == null ? null : t1.get$renderObject();
        if (scrollSemanticsRenderObject != null)
          scrollSemanticsRenderObject.markNeedsSemanticsUpdate$0();
      }
      return false;
    },
    build$1(context) {
      var t2, t3, t4, t5, t6, result, details, registrar, _this = this, _null = null,
        t1 = _this._scrollable$_position;
      t1.toString;
      t2 = _this._gestureRecognizers;
      t3 = _this._widget;
      t4 = t3.hitTestBehavior;
      t5 = t3.excludeFromSemantics;
      t6 = _this._shouldIgnorePointer;
      result = new B._ScrollableScope(_this, t1, A.Listener$(C.HitTestBehavior_0, new A.RawGestureDetector(A.Semantics$(_null, A.IgnorePointer$(t3.viewportBuilder$2(context, t1), t6, _this._ignorePointerKey), false, _null, _null, !t5, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null), t2, t4, t5, _this._gestureDetectorKey), _null, _null, _null, _this.get$_receivedPointerSignal(), _null), _null);
      t1 = _this._widget;
      if (!t1.excludeFromSemantics) {
        t2 = _this._scrollable$_position;
        t2.toString;
        _this._physics.toString;
        t3 = A.axisDirectionToAxis(t1.axisDirection);
        result = new A.NotificationListener(_this.get$_handleScrollMetricsNotification(), new B._ScrollSemantics(t2, true, t1.semanticChildCount, t3, result, _this._scrollSemanticsKey), _null, type$.NotificationListener_ScrollMetricsNotification);
      }
      t1 = t1.axisDirection;
      t2 = _this.get$_effectiveScrollController();
      t3 = _this._widget.clipBehavior;
      details = new B.ScrollableDetails(t1, t2, t3);
      t1 = _this.__ScrollableState__configuration_A;
      t1 === $ && A.throwUnnamedLateFieldNI();
      result = t1.buildScrollbar$3(context, t1.buildOverscrollIndicator$3(context, result, details), details);
      registrar = A.SelectionContainer_maybeOf(context);
      if (registrar != null) {
        t1 = _this._scrollable$_position;
        t1.toString;
        result = new B._ScrollableSelectionHandler(_this, t1, result, registrar, _null);
      }
      return result;
    },
    _performEnsureVisible$6$alignment$alignmentPolicy$curve$duration$targetRenderObject(object, alignment, alignmentPolicy, curve, duration, targetRenderObject) {
      return new A._Record_2(A._setArrayType([this._scrollable$_position.ensureVisible$6$alignment$alignmentPolicy$curve$duration$targetRenderObject(object, alignment, alignmentPolicy, curve, duration, targetRenderObject)], type$.JSArray_Future_void), this);
    }
  };
  B._ScrollableSelectionHandler.prototype = {
    createState$0() {
      return new B._ScrollableSelectionHandlerState();
    }
  };
  B._ScrollableSelectionHandlerState.prototype = {
    initState$0() {
      var t1, t2, t3, t4;
      this.super$State$initState();
      t1 = this._widget;
      t2 = t1.state;
      t1 = t1.position;
      t3 = type$.Selectable;
      t4 = type$.double;
      t3 = new B._ScrollableSelectionContainerDelegate(t2, new B.EdgeDraggingAutoScroller(t2, 30), t1, A.LinkedHashMap_LinkedHashMap$_empty(t3, t4), A.LinkedHashMap_LinkedHashMap$_empty(t3, t4), A._setArrayType([], type$.JSArray_Selectable), A.LinkedHashSet_LinkedHashSet$_empty(t3), C.SelectionGeometry_jnK, $.$get$ChangeNotifier__emptyListeners());
      t1.addListener$1(t3.get$_scheduleLayoutChange());
      this.___ScrollableSelectionHandlerState__selectionDelegate_A = t3;
    },
    didUpdateWidget$1(oldWidget) {
      var t1, t2;
      this.super$State$didUpdateWidget(oldWidget);
      t1 = this._widget.position;
      if (oldWidget.position !== t1) {
        t2 = this.___ScrollableSelectionHandlerState__selectionDelegate_A;
        t2 === $ && A.throwUnnamedLateFieldNI();
        t2.set$position(t1);
      }
    },
    dispose$0() {
      var t1 = this.___ScrollableSelectionHandlerState__selectionDelegate_A;
      t1 === $ && A.throwUnnamedLateFieldNI();
      t1.dispose$0();
      this.super$State$dispose();
    },
    build$1(context) {
      var t1 = this._widget,
        t2 = t1.registrar,
        t3 = this.___ScrollableSelectionHandlerState__selectionDelegate_A;
      t3 === $ && A.throwUnnamedLateFieldNI();
      return new A.SelectionContainer(t2, t1.child, t3, null);
    }
  };
  B._ScrollableSelectionContainerDelegate.prototype = {
    set$position(other) {
      var t2,
        t1 = this._scrollable$_position;
      if (other === t1)
        return;
      t2 = this.get$_scheduleLayoutChange();
      t1.removeListener$1(t2);
      this._scrollable$_position = other;
      other.addListener$1(t2);
    },
    _scheduleLayoutChange$0() {
      if (this._scheduledLayoutChange)
        return;
      this._scheduledLayoutChange = true;
      $.SchedulerBinding__instance.SchedulerBinding__postFrameCallbacks.push(new B._ScrollableSelectionContainerDelegate__scheduleLayoutChange_closure(this));
    },
    didChangeSelectables$0() {
      var _this = this,
        t1 = _this.selectables,
        selectableSet = A.LinkedHashSet_LinkedHashSet$from(t1, A._arrayInstanceType(t1)._precomputed1);
      _this._selectableStartEdgeUpdateRecords.removeWhere$1(0, new B._ScrollableSelectionContainerDelegate_didChangeSelectables_closure(selectableSet));
      _this._selectableEndEdgeUpdateRecords.removeWhere$1(0, new B._ScrollableSelectionContainerDelegate_didChangeSelectables_closure0(selectableSet));
      _this.super$MultiSelectableSelectionContainerDelegate$didChangeSelectables();
    },
    handleClearSelection$1($event) {
      var _this = this;
      _this._selectableStartEdgeUpdateRecords.clear$0(0);
      _this._selectableEndEdgeUpdateRecords.clear$0(0);
      _this._currentDragEndRelatedToOrigin = _this._currentDragStartRelatedToOrigin = null;
      _this._selectionStartsInScrollable = false;
      return _this.super$MultiSelectableSelectionContainerDelegate$handleClearSelection($event);
    },
    handleSelectionEdgeUpdate$1($event) {
      var deltaToOrigin, t1, t2, t3, t4, result, _this = this;
      if (_this._currentDragEndRelatedToOrigin == null && _this._currentDragStartRelatedToOrigin == null)
        _this._selectionStartsInScrollable = _this._globalPositionInScrollable$1($event.globalPosition);
      deltaToOrigin = B._getDeltaToScrollOrigin(_this.state);
      t1 = $event.globalPosition;
      t2 = $event.granularity;
      t3 = -deltaToOrigin._dx;
      t4 = -deltaToOrigin._dy;
      if ($event.type === C.SelectionEventType_1) {
        t1 = _this._currentDragEndRelatedToOrigin = _this._inferPositionRelatedToOrigin$1(t1);
        $event = A.SelectionEdgeUpdateEvent$forEnd(new A.Offset(t1._dx + t3, t1._dy + t4), t2);
      } else {
        t1 = _this._currentDragStartRelatedToOrigin = _this._inferPositionRelatedToOrigin$1(t1);
        $event = A.SelectionEdgeUpdateEvent$forStart(new A.Offset(t1._dx + t3, t1._dy + t4), t2);
      }
      result = _this.super$MultiSelectableSelectionContainerDelegate$handleSelectionEdgeUpdate($event);
      if (result === C.SelectionResult_3) {
        _this._autoScroller._scrolling = false;
        return result;
      }
      if (_this._selectionStartsInScrollable) {
        t1 = _this._autoScroller;
        t1.startAutoScrollIfNecessary$1(A.Rect$fromCenter($event.globalPosition, 0, 0));
        if (t1._scrolling)
          return C.SelectionResult_3;
      }
      return result;
    },
    _inferPositionRelatedToOrigin$1(globalPosition) {
      var localPosition, t3, deltaToOrigin,
        t1 = this.state,
        t2 = t1._framework$_element.get$renderObject();
      t2.toString;
      type$.RenderBox._as(t2);
      localPosition = t2.globalToLocal$1(globalPosition);
      if (!this._selectionStartsInScrollable) {
        t3 = localPosition._dy;
        if (t3 < 0 || localPosition._dx < 0)
          return A.MatrixUtils_transformPoint(t2.getTransformTo$1(null), C.Offset_0_0);
        if (t3 > t2.get$size()._dy || localPosition._dx > t2.get$size()._dx)
          return D.Offset_xfs;
      }
      deltaToOrigin = B._getDeltaToScrollOrigin(t1);
      return A.MatrixUtils_transformPoint(t2.getTransformTo$1(null), new A.Offset(localPosition._dx + deltaToOrigin._dx, localPosition._dy + deltaToOrigin._dy));
    },
    _updateDragLocationsFromGeometries$2$forceUpdateEnd$forceUpdateStart(forceUpdateEnd, forceUpdateStart) {
      var transform, t2, t3, _this = this,
        t1 = _this.state,
        deltaToOrigin = B._getDeltaToScrollOrigin(t1);
      t1 = t1._framework$_element.get$renderObject();
      t1.toString;
      type$.RenderBox._as(t1);
      transform = t1.getTransformTo$1(null);
      t2 = _this.currentSelectionStartIndex;
      if (t2 !== -1)
        t3 = _this._currentDragStartRelatedToOrigin == null || forceUpdateStart;
      else
        t3 = false;
      if (t3) {
        t2 = _this.selectables[t2].get$value().startSelectionPoint;
        t2.toString;
        _this._currentDragStartRelatedToOrigin = A.MatrixUtils_transformPoint(transform, A.MatrixUtils_transformPoint(_this.selectables[_this.currentSelectionStartIndex].getTransformTo$1(t1), t2.localPosition.$add(0, new A.Offset(0, -t2.lineHeight / 2))).$add(0, deltaToOrigin));
      }
      t2 = _this.currentSelectionEndIndex;
      if (t2 !== -1) {
        t2 = _this.selectables[t2].get$value().endSelectionPoint;
        t2.toString;
        _this._currentDragEndRelatedToOrigin = A.MatrixUtils_transformPoint(transform, A.MatrixUtils_transformPoint(_this.selectables[_this.currentSelectionEndIndex].getTransformTo$1(t1), t2.localPosition.$add(0, new A.Offset(0, -t2.lineHeight / 2))).$add(0, deltaToOrigin));
      }
    },
    _updateDragLocationsFromGeometries$0() {
      return this._updateDragLocationsFromGeometries$2$forceUpdateEnd$forceUpdateStart(true, true);
    },
    handleSelectAll$1($event) {
      var result = this.super$MultiSelectableSelectionContainerDelegate$handleSelectAll($event);
      if (this.currentSelectionStartIndex !== -1)
        this._updateDragLocationsFromGeometries$0();
      return result;
    },
    handleSelectWord$1($event) {
      var result, _this = this;
      _this._selectionStartsInScrollable = _this._globalPositionInScrollable$1($event.get$globalPosition());
      result = _this.super$MultiSelectableSelectionContainerDelegate$handleSelectWord($event);
      _this._updateDragLocationsFromGeometries$0();
      return result;
    },
    handleGranularlyExtendSelection$1($event) {
      var _this = this,
        result = _this.super$MultiSelectableSelectionContainerDelegate$handleGranularlyExtendSelection($event),
        t1 = $event.get$isEnd();
      _this._updateDragLocationsFromGeometries$2$forceUpdateEnd$forceUpdateStart($event.get$isEnd(), !t1);
      if (_this._selectionStartsInScrollable)
        _this._jumpToEdge$1($event.get$isEnd());
      return result;
    },
    handleDirectionallyExtendSelection$1($event) {
      var _this = this,
        result = _this.super$MultiSelectableSelectionContainerDelegate$handleDirectionallyExtendSelection($event),
        t1 = $event.get$isEnd();
      _this._updateDragLocationsFromGeometries$2$forceUpdateEnd$forceUpdateStart($event.get$isEnd(), !t1);
      if (_this._selectionStartsInScrollable)
        _this._jumpToEdge$1($event.get$isEnd());
      return result;
    },
    _jumpToEdge$1(isExtent) {
      var selectable, edge, lineHeight, t2, edgeOffsetInScrollableCoordinates, t3, edgeBottom, edgeTop, _this = this,
        t1 = _this.selectables;
      if (isExtent) {
        selectable = t1[_this.currentSelectionEndIndex];
        edge = selectable.get$value().endSelectionPoint;
        lineHeight = selectable.get$value().endSelectionPoint.lineHeight;
      } else {
        selectable = t1[_this.currentSelectionStartIndex];
        edge = selectable.get$value().startSelectionPoint;
        t1 = selectable.get$value().startSelectionPoint;
        lineHeight = t1 == null ? null : t1.lineHeight;
      }
      if (lineHeight == null || edge == null)
        return;
      t1 = _this.state;
      t2 = t1._framework$_element.get$renderObject();
      t2.toString;
      type$.RenderBox._as(t2);
      edgeOffsetInScrollableCoordinates = A.MatrixUtils_transformPoint(selectable.getTransformTo$1(t2), edge.localPosition);
      t3 = t2.get$size()._dx;
      t2 = t2.get$size()._dy;
      switch (t1._widget.axisDirection.index) {
        case 0:
          edgeBottom = edgeOffsetInScrollableCoordinates._dy;
          edgeTop = edgeBottom - lineHeight;
          if (edgeBottom >= t2 && edgeTop <= 0)
            return;
          if (edgeBottom > t2) {
            t1 = _this._scrollable$_position;
            t3 = t1._pixels;
            t3.toString;
            t1.jumpTo$1(t3 + t2 - edgeBottom);
            return;
          }
          if (edgeTop < 0) {
            t1 = _this._scrollable$_position;
            t2 = t1._pixels;
            t2.toString;
            t1.jumpTo$1(t2 + 0 - edgeTop);
          }
          return;
        case 1:
          edge = edgeOffsetInScrollableCoordinates._dx;
          if (edge >= t3 && edge <= 0)
            return;
          if (edge > t3) {
            t1 = _this._scrollable$_position;
            t2 = t1._pixels;
            t2.toString;
            t1.jumpTo$1(t2 + edge - t3);
            return;
          }
          if (edge < 0) {
            t1 = _this._scrollable$_position;
            t2 = t1._pixels;
            t2.toString;
            t1.jumpTo$1(t2 + edge);
          }
          return;
        case 2:
          edgeBottom = edgeOffsetInScrollableCoordinates._dy;
          edgeTop = edgeBottom - lineHeight;
          if (edgeBottom >= t2 && edgeTop <= 0)
            return;
          if (edgeBottom > t2) {
            t1 = _this._scrollable$_position;
            t3 = t1._pixels;
            t3.toString;
            t1.jumpTo$1(t3 + edgeBottom - t2);
            return;
          }
          if (edgeTop < 0) {
            t1 = _this._scrollable$_position;
            t2 = t1._pixels;
            t2.toString;
            t1.jumpTo$1(t2 + edgeTop);
          }
          return;
        case 3:
          edge = edgeOffsetInScrollableCoordinates._dx;
          if (edge >= t3 && edge <= 0)
            return;
          if (edge > t3) {
            t1 = _this._scrollable$_position;
            t2 = t1._pixels;
            t2.toString;
            t1.jumpTo$1(t2 + t3 - edge);
            return;
          }
          if (edge < 0) {
            t1 = _this._scrollable$_position;
            t2 = t1._pixels;
            t2.toString;
            t1.jumpTo$1(t2 + 0 - edge);
          }
          return;
      }
    },
    _globalPositionInScrollable$1(globalPosition) {
      var localPosition,
        t1 = this.state._framework$_element.get$renderObject();
      t1.toString;
      type$.RenderBox._as(t1);
      localPosition = t1.globalToLocal$1(globalPosition);
      return new A.Rect(0, 0, 0 + t1.get$size()._dx, 0 + t1.get$size()._dy).contains$1(0, localPosition);
    },
    dispatchSelectionEventToChild$2(selectable, $event) {
      var t1, t2, _this = this;
      switch ($event.type.index) {
        case 0:
          t1 = _this.state._scrollable$_position._pixels;
          t1.toString;
          _this._selectableStartEdgeUpdateRecords.$indexSet(0, selectable, t1);
          _this.ensureChildUpdated$1(selectable);
          break;
        case 1:
          t1 = _this.state._scrollable$_position._pixels;
          t1.toString;
          _this._selectableEndEdgeUpdateRecords.$indexSet(0, selectable, t1);
          _this.ensureChildUpdated$1(selectable);
          break;
        case 6:
        case 7:
          _this.ensureChildUpdated$1(selectable);
          t1 = _this.state;
          t2 = t1._scrollable$_position._pixels;
          t2.toString;
          _this._selectableStartEdgeUpdateRecords.$indexSet(0, selectable, t2);
          t1 = t1._scrollable$_position._pixels;
          t1.toString;
          _this._selectableEndEdgeUpdateRecords.$indexSet(0, selectable, t1);
          break;
        case 2:
          _this._selectableEndEdgeUpdateRecords.remove$1(0, selectable);
          _this._selectableStartEdgeUpdateRecords.remove$1(0, selectable);
          break;
        case 3:
        case 4:
        case 5:
          t1 = _this.state;
          t2 = t1._scrollable$_position._pixels;
          t2.toString;
          _this._selectableEndEdgeUpdateRecords.$indexSet(0, selectable, t2);
          t1 = t1._scrollable$_position._pixels;
          t1.toString;
          _this._selectableStartEdgeUpdateRecords.$indexSet(0, selectable, t1);
          break;
      }
      return _this.super$MultiSelectableSelectionContainerDelegate$dispatchSelectionEventToChild(selectable, $event);
    },
    ensureChildUpdated$1(selectable) {
      var t3, previousStartRecord, t4, t5, deltaToOrigin, previousEndRecord, _this = this,
        t1 = _this.state,
        t2 = t1._scrollable$_position._pixels;
      t2.toString;
      t3 = _this._selectableStartEdgeUpdateRecords;
      previousStartRecord = t3.$index(0, selectable);
      t4 = _this._currentDragStartRelatedToOrigin;
      if (t4 != null)
        t5 = previousStartRecord == null || Math.abs(t2 - previousStartRecord) > 1e-10;
      else
        t5 = false;
      if (t5) {
        deltaToOrigin = B._getDeltaToScrollOrigin(t1);
        selectable.dispatchSelectionEvent$1(A.SelectionEdgeUpdateEvent$forStart(new A.Offset(t4._dx + -deltaToOrigin._dx, t4._dy + -deltaToOrigin._dy), null));
        t4 = t1._scrollable$_position._pixels;
        t4.toString;
        t3.$indexSet(0, selectable, t4);
      }
      t3 = _this._selectableEndEdgeUpdateRecords;
      previousEndRecord = t3.$index(0, selectable);
      t4 = _this._currentDragEndRelatedToOrigin;
      if (t4 != null)
        t2 = previousEndRecord == null || Math.abs(t2 - previousEndRecord) > 1e-10;
      else
        t2 = false;
      if (t2) {
        deltaToOrigin = B._getDeltaToScrollOrigin(t1);
        selectable.dispatchSelectionEvent$1(A.SelectionEdgeUpdateEvent$forEnd(new A.Offset(t4._dx + -deltaToOrigin._dx, t4._dy + -deltaToOrigin._dy), null));
        t1 = t1._scrollable$_position._pixels;
        t1.toString;
        t3.$indexSet(0, selectable, t1);
      }
    },
    dispose$0() {
      var _this = this;
      _this._selectableStartEdgeUpdateRecords.clear$0(0);
      _this._selectableEndEdgeUpdateRecords.clear$0(0);
      _this._scheduledLayoutChange = false;
      _this._autoScroller._scrolling = false;
      _this.super$MultiSelectableSelectionContainerDelegate$dispose();
    }
  };
  B._ScrollSemantics.prototype = {
    createRenderObject$1(context) {
      var t1 = this.position,
        t2 = new B._RenderScrollSemantics(t1, true, this.axis, this.semanticChildCount, null, new A._LayoutCacheStorage(), A.LayerHandle$());
      t2.RenderObject$0();
      t2.set$child(null);
      t1.addListener$1(t2.get$markNeedsSemanticsUpdate());
      return t2;
    },
    updateRenderObject$2(context, renderObject) {
      renderObject.set$allowImplicitScrolling(true);
      renderObject.axis = this.axis;
      renderObject.set$position(this.position);
      renderObject.set$semanticChildCount(this.semanticChildCount);
    }
  };
  B._RenderScrollSemantics.prototype = {
    set$position(value) {
      var t2, _this = this,
        t1 = _this._scrollable$_position;
      if (value === t1)
        return;
      t2 = _this.get$markNeedsSemanticsUpdate();
      t1.removeListener$1(t2);
      _this._scrollable$_position = value;
      value.addListener$1(t2);
      _this.markNeedsSemanticsUpdate$0();
    },
    set$allowImplicitScrolling(value) {
      return;
    },
    set$semanticChildCount(value) {
      if (value == this._semanticChildCount)
        return;
      this._semanticChildCount = value;
      this.markNeedsSemanticsUpdate$0();
    },
    _onScrollToOffset$1(targetOffset) {
      var t1;
      switch (this.axis.index) {
        case 0:
          t1 = targetOffset._dx;
          break;
        case 1:
          t1 = targetOffset._dy;
          break;
        default:
          t1 = null;
      }
      this._scrollable$_position.jumpTo$1(t1);
    },
    describeSemanticsConfiguration$1(config) {
      var t1, t2, _this = this;
      _this.super$RenderObject$describeSemanticsConfiguration(config);
      config._isSemanticBoundary = true;
      if (_this._scrollable$_position._haveDimensions) {
        config._setFlag$2(C.SemanticsFlag_262144_hasImplicitScrolling, true);
        t1 = _this._scrollable$_position;
        t2 = t1._pixels;
        t2.toString;
        config._scrollPosition = t2;
        config._hasBeenAnnotated = true;
        t2 = t1._scroll_position$_maxScrollExtent;
        t2.toString;
        config._scrollExtentMax = t2;
        t1 = t1._scroll_position$_minScrollExtent;
        t1.toString;
        config._scrollExtentMin = t1;
        config.set$scrollChildCount(_this._semanticChildCount);
        t1 = _this._scrollable$_position;
        t2 = t1._scroll_position$_maxScrollExtent;
        t2.toString;
        t1 = t1._scroll_position$_minScrollExtent;
        t1.toString;
        if (t2 > t1)
          config.set$onScrollToOffset(_this.get$_onScrollToOffset());
      }
    },
    assembleSemanticsNode$3(node, config, children) {
      var t1, t2, excluded, included, firstVisibleIndex, _i, child, _this = this;
      if (children.length !== 0) {
        t1 = C.JSArray_methods.get$first(children).tags;
        t1 = !(t1 != null && t1.contains$1(0, D.SemanticsTag_C6p));
      } else
        t1 = true;
      if (t1) {
        _this._innerNode = null;
        _this.super$RenderObject$assembleSemanticsNode(node, config, children);
        return;
      }
      t1 = _this._innerNode;
      if (t1 == null)
        t1 = _this._innerNode = A.SemanticsNode$(null, _this.get$showOnScreen());
      t1.set$rect(node._semantics$_rect);
      t1 = _this._innerNode;
      t1.toString;
      t2 = type$.JSArray_SemanticsNode;
      excluded = A._setArrayType([t1], t2);
      included = A._setArrayType([], t2);
      for (t1 = children.length, firstVisibleIndex = null, _i = 0; _i < children.length; children.length === t1 || (0, A.throwConcurrentModificationError)(children), ++_i) {
        child = children[_i];
        t2 = child.tags;
        if (t2 != null && t2.contains$1(0, D.SemanticsTag_W8h))
          excluded.push(child);
        else {
          if ((child._flags & 8192) === 0)
            firstVisibleIndex = firstVisibleIndex == null ? child.indexInParent : firstVisibleIndex;
          included.push(child);
        }
      }
      config.set$scrollIndex(firstVisibleIndex);
      node.updateWith$2$childrenInInversePaintOrder$config(excluded, null);
      _this._innerNode.updateWith$2$childrenInInversePaintOrder$config(included, config);
    },
    clearSemantics$0() {
      this.super$RenderObject$clearSemantics();
      this._innerNode = null;
    }
  };
  B._RestorableScrollOffset.prototype = {
    createDefaultValue$0() {
      return null;
    },
    didUpdateValue$1(oldValue) {
      this.notifyListeners$0();
    },
    fromPrimitives$1(data) {
      data.toString;
      return A._asDouble(data);
    },
    toPrimitives$0() {
      var t1 = this._restoration_properties$_value;
      return t1 == null ? A._instanceType(this)._eval$1("RestorableValue.T")._as(t1) : t1;
    },
    get$enabled() {
      var t1 = this._restoration_properties$_value;
      return (t1 == null ? A._instanceType(this)._eval$1("RestorableValue.T")._as(t1) : t1) != null;
    }
  };
  B._ScrollableState_State_TickerProviderStateMixin.prototype = {
    activate$0() {
      this.super$State$activate();
      this._updateTickerModeNotifier$0();
      this._updateTickers$0();
    },
    dispose$0() {
      var _this = this,
        t1 = _this.TickerProviderStateMixin__tickerModeNotifier;
      if (t1 != null)
        t1.removeListener$1(_this.get$_updateTickers());
      _this.TickerProviderStateMixin__tickerModeNotifier = null;
      _this.super$State$dispose();
    }
  };
  B._ScrollableState_State_TickerProviderStateMixin_RestorationMixin.prototype = {
    didUpdateWidget$1(oldWidget) {
      this.super$State$didUpdateWidget(oldWidget);
      this.didUpdateRestorationId$0();
    },
    didChangeDependencies$0() {
      var oldBucket, needsRestore, t1, didReplaceBucket, _this = this;
      _this.super$State$didChangeDependencies();
      oldBucket = _this.RestorationMixin__bucket;
      needsRestore = _this.get$restorePending();
      t1 = _this._framework$_element;
      t1.toString;
      t1 = A.RestorationScope_maybeOf(t1);
      _this.RestorationMixin__currentParent = t1;
      didReplaceBucket = _this._updateBucketIfNecessary$2$parent$restorePending(t1, needsRestore);
      if (needsRestore) {
        _this.restoreState$2(oldBucket, _this.RestorationMixin__firstRestorePending);
        _this.RestorationMixin__firstRestorePending = false;
      }
      if (didReplaceBucket)
        if (oldBucket != null)
          oldBucket.dispose$0();
    },
    dispose$0() {
      var t1, _this = this;
      _this.RestorationMixin__properties.forEach$1(0, new B._ScrollableState_State_TickerProviderStateMixin_RestorationMixin_dispose_closure());
      t1 = _this.RestorationMixin__bucket;
      if (t1 != null)
        t1.dispose$0();
      _this.RestorationMixin__bucket = null;
      _this.super$_ScrollableState_State_TickerProviderStateMixin$dispose();
    }
  };
  B.ScrollableDetails.prototype = {
    get$clipBehavior() {
      return this.decorationClipBehavior;
    },
    toString$0(_) {
      var t1, _this = this,
        description = A._setArrayType([], type$.JSArray_String);
      description.push("axisDirection: " + _this.direction.toString$0(0));
      t1 = new B.ScrollableDetails_toString_addIfNonNull(description);
      t1.call$2("scroll controller: ", _this.controller);
      t1.call$2("scroll physics: ", null);
      t1.call$2("decorationClipBehavior: ", _this.decorationClipBehavior);
      return "<optimized out>#" + A.shortHash(_this) + "(" + C.JSArray_methods.join$1(description, ", ") + ")";
    },
    get$hashCode(_) {
      return A.Object_hash(this.direction, this.controller, null, this.decorationClipBehavior, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue);
    },
    $eq(_, other) {
      var t1, _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (J.get$runtimeType$(other) !== A.getRuntimeTypeOfDartObject(_this))
        return false;
      t1 = false;
      if (other instanceof B.ScrollableDetails)
        if (other.direction === _this.direction)
          if (other.controller === _this.controller)
            t1 = other.decorationClipBehavior === _this.decorationClipBehavior;
      return t1;
    }
  };
  B.EdgeDraggingAutoScroller.prototype = {
    _offsetExtent$2(offset, scrollDirection) {
      var t1;
      switch (scrollDirection.index) {
        case 0:
          t1 = offset._dx;
          break;
        case 1:
          t1 = offset._dy;
          break;
        default:
          t1 = null;
      }
      return t1;
    },
    _sizeExtent$2(size, scrollDirection) {
      var t1;
      switch (scrollDirection.index) {
        case 0:
          t1 = size._dx;
          break;
        case 1:
          t1 = size._dy;
          break;
        default:
          t1 = null;
      }
      return t1;
    },
    startAutoScrollIfNecessary$1(dragTarget) {
      var _this = this,
        deltaToOrigin = _this.scrollable.get$deltaToScrollOrigin();
      _this.__EdgeDraggingAutoScroller__dragTargetRelatedToScrollOrigin_A = dragTarget.translate$2(deltaToOrigin._dx, deltaToOrigin._dy);
      if (_this._scrolling)
        return;
      _this._scroll$0();
    },
    _scroll$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$returnValue, $async$self = this, globalRect, deltaToOrigin, t3, viewportStart, viewportEnd, proxyStart, proxyEnd, newOffset, overDrag, duration, t1, t2;
      var $async$_scroll$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.scrollable;
              t2 = t1._framework$_element.get$renderObject();
              t2.toString;
              type$.RenderBox._as(t2);
              globalRect = A.MatrixUtils_transformRect(t2.getTransformTo$1(null), new A.Rect(0, 0, 0 + t2.get$size()._dx, 0 + t2.get$size()._dy));
              $async$self._scrolling = true;
              deltaToOrigin = t1.get$deltaToScrollOrigin();
              t2 = globalRect.left;
              t3 = globalRect.top;
              viewportStart = $async$self._offsetExtent$2(new A.Offset(t2 + deltaToOrigin._dx, t3 + deltaToOrigin._dy), A.axisDirectionToAxis(t1._widget.axisDirection));
              viewportEnd = viewportStart + $async$self._sizeExtent$2(new A.Size(globalRect.right - t2, globalRect.bottom - t3), A.axisDirectionToAxis(t1._widget.axisDirection));
              t3 = $async$self.__EdgeDraggingAutoScroller__dragTargetRelatedToScrollOrigin_A;
              t3 === $ && A.throwUnnamedLateFieldNI();
              proxyStart = $async$self._offsetExtent$2(new A.Offset(t3.left, t3.top), A.axisDirectionToAxis(t1._widget.axisDirection));
              t3 = $async$self.__EdgeDraggingAutoScroller__dragTargetRelatedToScrollOrigin_A;
              proxyEnd = $async$self._offsetExtent$2(new A.Offset(t3.right, t3.bottom), A.axisDirectionToAxis(t1._widget.axisDirection));
              newOffset = null;
              switch (t1._widget.axisDirection.index) {
                case 0:
                case 3:
                  if (proxyEnd > viewportEnd) {
                    t2 = t1._scrollable$_position;
                    t3 = t2._pixels;
                    t3.toString;
                    t2 = t2._scroll_position$_minScrollExtent;
                    t2.toString;
                    t2 = t3 > t2;
                  } else
                    t2 = false;
                  if (t2) {
                    overDrag = Math.min(proxyEnd - viewportEnd, 20);
                    t2 = t1._scrollable$_position;
                    t3 = t2._scroll_position$_minScrollExtent;
                    t3.toString;
                    t2 = t2._pixels;
                    t2.toString;
                    newOffset = Math.max(t3, t2 - overDrag);
                  } else {
                    if (proxyStart < viewportStart) {
                      t2 = t1._scrollable$_position;
                      t3 = t2._pixels;
                      t3.toString;
                      t2 = t2._scroll_position$_maxScrollExtent;
                      t2.toString;
                      t2 = t3 < t2;
                    } else
                      t2 = false;
                    if (t2) {
                      overDrag = Math.min(viewportStart - proxyStart, 20);
                      t2 = t1._scrollable$_position;
                      t3 = t2._scroll_position$_maxScrollExtent;
                      t3.toString;
                      t2 = t2._pixels;
                      t2.toString;
                      newOffset = Math.min(t3, t2 + overDrag);
                    }
                  }
                  break;
                case 1:
                case 2:
                  if (proxyStart < viewportStart) {
                    t2 = t1._scrollable$_position;
                    t3 = t2._pixels;
                    t3.toString;
                    t2 = t2._scroll_position$_minScrollExtent;
                    t2.toString;
                    t2 = t3 > t2;
                  } else
                    t2 = false;
                  if (t2) {
                    overDrag = Math.min(viewportStart - proxyStart, 20);
                    t2 = t1._scrollable$_position;
                    t3 = t2._scroll_position$_minScrollExtent;
                    t3.toString;
                    t2 = t2._pixels;
                    t2.toString;
                    newOffset = Math.max(t3, t2 - overDrag);
                  } else {
                    if (proxyEnd > viewportEnd) {
                      t2 = t1._scrollable$_position;
                      t3 = t2._pixels;
                      t3.toString;
                      t2 = t2._scroll_position$_maxScrollExtent;
                      t2.toString;
                      t2 = t3 < t2;
                    } else
                      t2 = false;
                    if (t2) {
                      overDrag = Math.min(proxyEnd - viewportEnd, 20);
                      t2 = t1._scrollable$_position;
                      t3 = t2._scroll_position$_maxScrollExtent;
                      t3.toString;
                      t2 = t2._pixels;
                      t2.toString;
                      newOffset = Math.min(t3, t2 + overDrag);
                    }
                  }
                  break;
              }
              if (newOffset != null) {
                t2 = t1._scrollable$_position._pixels;
                t2.toString;
                t2 = Math.abs(newOffset - t2) < 1;
              } else
                t2 = true;
              if (t2) {
                $async$self._scrolling = false;
                // goto return
                $async$goto = 1;
                break;
              }
              duration = A.Duration$(0, C.JSNumber_methods.round$0(1000 / $async$self.velocityScalar));
              $async$goto = 3;
              return A._asyncAwait(t1._scrollable$_position.animateTo$3$curve$duration(newOffset, C.C__Linear, duration), $async$_scroll$0);
            case 3:
              // returning from await.
              $async$goto = $async$self._scrolling ? 4 : 5;
              break;
            case 4:
              // then
              $async$goto = 6;
              return A._asyncAwait($async$self._scroll$0(), $async$_scroll$0);
            case 6:
              // returning from await.
            case 5:
              // join
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$_scroll$0, $async$completer);
    }
  };
  var typesOffset = hunkHelpers.updateTypes(["~()", "~(DragDownDetails)", "~(DragStartDetails)", "~(DragUpdateDetails)", "~(DragEndDetails)", "~(PointerSignalEvent)", "~(PointerEvent)", "bool(ScrollMetricsNotification)", "~(Offset)"]);
  B._ScrollableState_State_TickerProviderStateMixin_RestorationMixin_dispose_closure.prototype = {
    call$2(property, listener) {
      if (!property._restoration0$_disposed)
        property.removeListener$1(listener);
    },
    $signature: 44
  };
  B.ScrollableState_setCanDrag_closure.prototype = {
    call$0() {
      var t1 = this.$this.__ScrollableState__configuration_A;
      t1 === $ && A.throwUnnamedLateFieldNI();
      return A.VerticalDragGestureRecognizer$(null, t1.get$dragDevices());
    },
    $signature: 170
  };
  B.ScrollableState_setCanDrag_closure0.prototype = {
    call$1(instance) {
      var t2, t3,
        t1 = this.$this;
      instance.onDown = t1.get$_handleDragDown();
      instance.onStart = t1.get$_scrollable$_handleDragStart();
      instance.onUpdate = t1.get$_scrollable$_handleDragUpdate();
      instance.onEnd = t1.get$_scrollable$_handleDragEnd();
      instance.onCancel = t1.get$_scrollable$_handleDragCancel();
      t2 = t1._physics;
      instance.minFlingDistance = t2 == null ? null : t2.get$minFlingDistance();
      t2 = t1._physics;
      instance.minFlingVelocity = t2 == null ? null : t2.get$minFlingVelocity();
      t2 = t1._physics;
      instance.maxFlingVelocity = t2 == null ? null : t2.get$maxFlingVelocity();
      t2 = t1.__ScrollableState__configuration_A;
      t2 === $ && A.throwUnnamedLateFieldNI();
      t3 = t1._framework$_element;
      t3.toString;
      instance.velocityTrackerBuilder = t2.velocityTrackerBuilder$1(t3);
      instance.dragStartBehavior = t1._widget.dragStartBehavior;
      t3 = t1.__ScrollableState__configuration_A;
      t2 = t1._framework$_element;
      t2.toString;
      instance.multitouchDragStrategy = t3.getMultitouchDragStrategy$1(t2);
      instance.gestureSettings = t1._mediaQueryGestureSettings;
      instance.supportedDevices = t1.__ScrollableState__configuration_A.get$dragDevices();
    },
    $signature: 171
  };
  B.ScrollableState_setCanDrag_closure1.prototype = {
    call$0() {
      var t1 = this.$this.__ScrollableState__configuration_A;
      t1 === $ && A.throwUnnamedLateFieldNI();
      return A.HorizontalDragGestureRecognizer$(null, t1.get$dragDevices());
    },
    $signature: 172
  };
  B.ScrollableState_setCanDrag_closure2.prototype = {
    call$1(instance) {
      var t2, t3,
        t1 = this.$this;
      instance.onDown = t1.get$_handleDragDown();
      instance.onStart = t1.get$_scrollable$_handleDragStart();
      instance.onUpdate = t1.get$_scrollable$_handleDragUpdate();
      instance.onEnd = t1.get$_scrollable$_handleDragEnd();
      instance.onCancel = t1.get$_scrollable$_handleDragCancel();
      t2 = t1._physics;
      instance.minFlingDistance = t2 == null ? null : t2.get$minFlingDistance();
      t2 = t1._physics;
      instance.minFlingVelocity = t2 == null ? null : t2.get$minFlingVelocity();
      t2 = t1._physics;
      instance.maxFlingVelocity = t2 == null ? null : t2.get$maxFlingVelocity();
      t2 = t1.__ScrollableState__configuration_A;
      t2 === $ && A.throwUnnamedLateFieldNI();
      t3 = t1._framework$_element;
      t3.toString;
      instance.velocityTrackerBuilder = t2.velocityTrackerBuilder$1(t3);
      instance.dragStartBehavior = t1._widget.dragStartBehavior;
      t3 = t1.__ScrollableState__configuration_A;
      t2 = t1._framework$_element;
      t2.toString;
      instance.multitouchDragStrategy = t3.getMultitouchDragStrategy$1(t2);
      instance.gestureSettings = t1._mediaQueryGestureSettings;
      instance.supportedDevices = t1.__ScrollableState__configuration_A.get$dragDevices();
    },
    $signature: 173
  };
  B._ScrollableSelectionContainerDelegate__scheduleLayoutChange_closure.prototype = {
    call$1(timeStamp) {
      var t1 = this.$this;
      if (!t1._scheduledLayoutChange)
        return;
      t1._scheduledLayoutChange = false;
      t1._updateSelectionGeometry$0();
    },
    $signature: 6
  };
  B._ScrollableSelectionContainerDelegate_didChangeSelectables_closure.prototype = {
    call$2(key, value) {
      return !this.selectableSet.contains$1(0, key);
    },
    $signature: 206
  };
  B._ScrollableSelectionContainerDelegate_didChangeSelectables_closure0.prototype = {
    call$2(key, value) {
      return !this.selectableSet.contains$1(0, key);
    },
    $signature: 206
  };
  B.ScrollableDetails_toString_addIfNonNull.prototype = {
    call$2(prefix, value) {
      if (value != null)
        this.description.push(prefix + value.toString$0(0));
    },
    $signature: 593
  };
  (function aliases() {
    var _ = B._ScrollableState_State_TickerProviderStateMixin.prototype;
    _.super$_ScrollableState_State_TickerProviderStateMixin$dispose = _.dispose$0;
    _ = B._ScrollableState_State_TickerProviderStateMixin_RestorationMixin.prototype;
    _.super$_ScrollableState_State_TickerProviderStateMixin_RestorationMixin$didUpdateWidget = _.didUpdateWidget$1;
    _.super$_ScrollableState_State_TickerProviderStateMixin_RestorationMixin$didChangeDependencies = _.didChangeDependencies$0;
    _.super$_ScrollableState_State_TickerProviderStateMixin_RestorationMixin$dispose = _.dispose$0;
  })();
  (function installTearOffs() {
    var _instance_1_u = hunkHelpers._instance_1u,
      _instance_0_u = hunkHelpers._instance_0u;
    var _;
    _instance_1_u(_ = B.ScrollableState.prototype, "get$_handleDragDown", "_handleDragDown$1", 1);
    _instance_1_u(_, "get$_scrollable$_handleDragStart", "_scrollable$_handleDragStart$1", 2);
    _instance_1_u(_, "get$_scrollable$_handleDragUpdate", "_scrollable$_handleDragUpdate$1", 3);
    _instance_1_u(_, "get$_scrollable$_handleDragEnd", "_scrollable$_handleDragEnd$1", 4);
    _instance_0_u(_, "get$_scrollable$_handleDragCancel", "_scrollable$_handleDragCancel$0", 0);
    _instance_0_u(_, "get$_disposeHold", "_disposeHold$0", 0);
    _instance_0_u(_, "get$_disposeDrag", "_disposeDrag$0", 0);
    _instance_1_u(_, "get$_receivedPointerSignal", "_receivedPointerSignal$1", 5);
    _instance_1_u(_, "get$_scrollable$_handlePointerScroll", "_scrollable$_handlePointerScroll$1", 6);
    _instance_1_u(_, "get$_handleScrollMetricsNotification", "_handleScrollMetricsNotification$1", 7);
    _instance_0_u(_ = B._ScrollableSelectionContainerDelegate.prototype, "get$_scheduleLayoutChange", "_scheduleLayoutChange$0", 0);
    _instance_0_u(_, "get$dispose", "dispose$0", 0);
    _instance_1_u(B._RenderScrollSemantics.prototype, "get$_onScrollToOffset", "_onScrollToOffset$1", 8);
  })();
  (function inheritance() {
    var _mixinHard = hunkHelpers.mixinHard,
      _inheritMany = hunkHelpers.inheritMany,
      _inherit = hunkHelpers.inherit;
    _inheritMany(A.Object, [B.RevealedOffset, B.ScrollableDetails, B.EdgeDraggingAutoScroller]);
    _inheritMany(A.Closure2Args, [B._ScrollableState_State_TickerProviderStateMixin_RestorationMixin_dispose_closure, B._ScrollableSelectionContainerDelegate_didChangeSelectables_closure, B._ScrollableSelectionContainerDelegate_didChangeSelectables_closure0, B.ScrollableDetails_toString_addIfNonNull]);
    _inheritMany(A.StatefulWidget, [B.Scrollable, B._ScrollableSelectionHandler]);
    _inherit(B._ScrollableScope, A.InheritedWidget);
    _inheritMany(A.State, [B._ScrollableState_State_TickerProviderStateMixin, B._ScrollableSelectionHandlerState]);
    _inherit(B._ScrollableState_State_TickerProviderStateMixin_RestorationMixin, B._ScrollableState_State_TickerProviderStateMixin);
    _inherit(B.ScrollableState, B._ScrollableState_State_TickerProviderStateMixin_RestorationMixin);
    _inheritMany(A.Closure0Args, [B.ScrollableState_setCanDrag_closure, B.ScrollableState_setCanDrag_closure1]);
    _inheritMany(A.Closure, [B.ScrollableState_setCanDrag_closure0, B.ScrollableState_setCanDrag_closure2, B._ScrollableSelectionContainerDelegate__scheduleLayoutChange_closure]);
    _inherit(B._ScrollableSelectionContainerDelegate, A.MultiSelectableSelectionContainerDelegate);
    _inherit(B._ScrollSemantics, A.SingleChildRenderObjectWidget);
    _inherit(B._RenderScrollSemantics, A.RenderProxyBox);
    _inherit(B._RestorableScrollOffset, A.RestorableValue);
    _mixinHard(B._ScrollableState_State_TickerProviderStateMixin, A.TickerProviderStateMixin);
    _mixinHard(B._ScrollableState_State_TickerProviderStateMixin_RestorationMixin, A.RestorationMixin);
  })();
  A._Universe_addRules(init.typeUniverse, JSON.parse('{"Scrollable":{"StatefulWidget":[],"Widget":[],"DiagnosticableTree":[]},"_ScrollableSelectionHandler":{"StatefulWidget":[],"Widget":[],"DiagnosticableTree":[]},"_ScrollableScope":{"InheritedWidget":[],"ProxyWidget":[],"Widget":[],"DiagnosticableTree":[]},"ScrollableState":{"State":["Scrollable"]},"_ScrollableSelectionHandlerState":{"State":["_ScrollableSelectionHandler"]},"_ScrollableSelectionContainerDelegate":{"Listenable":[]},"_ScrollSemantics":{"SingleChildRenderObjectWidget":[],"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[]},"_RenderScrollSemantics":{"RenderBox":[],"RenderObjectWithChildMixin":["RenderBox"],"RenderObject":[],"DiagnosticableTree":[],"HitTestTarget":[]},"_RestorableScrollOffset":{"RestorableValue":["double?"],"RestorableProperty":["double?"],"Listenable":[],"RestorableValue.T":"double?"}}'));
  var type$ = (function rtii() {
    var findType = A.findType;
    return {
      GestureRecognizerFactoryWithHandlers_HorizontalDragGestureRecognizer: findType("GestureRecognizerFactoryWithHandlers<HorizontalDragGestureRecognizer>"),
      GestureRecognizerFactoryWithHandlers_VerticalDragGestureRecognizer: findType("GestureRecognizerFactoryWithHandlers<VerticalDragGestureRecognizer>"),
      GestureRecognizerFactory_GestureRecognizer: findType("GestureRecognizerFactory<GestureRecognizer>"),
      JSArray_Future_void: findType("JSArray<Future<~>>"),
      JSArray_Selectable: findType("JSArray<Selectable0>"),
      JSArray_SemanticsNode: findType("JSArray<SemanticsNode>"),
      JSArray_String: findType("JSArray<String>"),
      LabeledGlobalKey_RawGestureDetectorState: findType("LabeledGlobalKey<RawGestureDetectorState>"),
      LabeledGlobalKey_State_StatefulWidget: findType("LabeledGlobalKey<State<StatefulWidget>>"),
      NotificationListener_ScrollMetricsNotification: findType("NotificationListener<ScrollMetricsNotification>"),
      PointerScrollEvent: findType("PointerScrollEvent"),
      PointerScrollInertiaCancelEvent: findType("PointerScrollInertiaCancelEvent"),
      RenderBox: findType("RenderBox"),
      RenderIgnorePointer: findType("RenderIgnorePointer"),
      RenderSemanticsGestureHandler: findType("RenderSemanticsGestureHandler"),
      RestorableProperty_nullable_Object: findType("RestorableProperty<Object?>"),
      Selectable: findType("Selectable0"),
      Type: findType("Type"),
      double: findType("double"),
      void: findType("~"),
      void_Function: findType("~()")
    };
  })();
  (function constants() {
    D.Offset_xfs = new A.Offset(1 / 0, 1 / 0);
    D.SemanticsTag_C6p = new A.SemanticsTag("RenderViewport.twoPane");
    D.SemanticsTag_W8h = new A.SemanticsTag("RenderViewport.excludeFromScrolling");
  })();
};
;
((d, h) => {
  d[h] = d.current;
  d.eventLog.push({p: "main.dart.js_4", e: "endPart", h: h});
})($__dart_deferred_initializers__, "gXxV1l60lGhDJGgLYwPrDvVlLPQ=");
;