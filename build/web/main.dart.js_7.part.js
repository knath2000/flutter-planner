// Generated by dart2js (NullSafetyMode.sound, trust primitives, omit checks, lax runtime type, csp, intern-composite-values), the Dart to JavaScript compiler version: 3.7.2.
((s, d, e) => {
  s[d] = s[d] || {};
  s[d][e] = s[d][e] || [];
  s[d][e].push({p: "main.dart.js_7", e: "beginPart"});
})(self, "$__dart_deferred_initializers__", "eventLog");
$__dart_deferred_initializers__.current = function(hunkHelpers, init, holdersList, $) {
  var J, B, A, D,
  C = {OutlineInputBorder: function OutlineInputBorder(t0, t1, t2) {
      this.gapPadding = t0;
      this.borderRadius = t1;
      this.borderSide = t2;
    }};
  J = holdersList[1];
  B = holdersList[0];
  A = holdersList[2];
  D = holdersList[10];
  C = hunkHelpers.updateHolder(holdersList[7], C);
  C.OutlineInputBorder.prototype = {
    get$isOutline() {
      return true;
    },
    copyWith$1$borderSide(borderSide) {
      var t1 = borderSide == null ? this.borderSide : borderSide;
      return new C.OutlineInputBorder(this.gapPadding, this.borderRadius, t1);
    },
    get$dimensions() {
      var t1 = this.borderSide.width;
      return new B.EdgeInsets(t1, t1, t1, t1);
    },
    scale$1(t) {
      var t1 = this.borderSide.scale$1(t);
      return new C.OutlineInputBorder(this.gapPadding * t, this.borderRadius.$mul(0, t), t1);
    },
    lerpFrom$2(a, t) {
      var t1, t2;
      if (a instanceof C.OutlineInputBorder) {
        t1 = B.BorderRadius_lerp(a.borderRadius, this.borderRadius, t);
        t1.toString;
        t2 = B.BorderSide_lerp(a.borderSide, this.borderSide, t);
        return new C.OutlineInputBorder(a.gapPadding, t1, t2);
      }
      return this.super$ShapeBorder$lerpFrom(a, t);
    },
    lerpTo$2(b, t) {
      var t1, t2;
      if (b instanceof C.OutlineInputBorder) {
        t1 = B.BorderRadius_lerp(this.borderRadius, b.borderRadius, t);
        t1.toString;
        t2 = B.BorderSide_lerp(this.borderSide, b.borderSide, t);
        return new C.OutlineInputBorder(b.gapPadding, t1, t2);
      }
      return this.super$ShapeBorder$lerpTo(b, t);
    },
    getInnerPath$2$textDirection(rect, textDirection) {
      var t1 = $.$get$_renderer().createPath$0();
      t1.addRRect$1(this.borderRadius.toRRect$1(rect).inflate$1(-this.borderSide.width));
      return t1;
    },
    getOuterPath$2$textDirection(rect, textDirection) {
      var t1 = $.$get$_renderer().createPath$0();
      t1.addRRect$1(this.borderRadius.toRRect$1(rect));
      return t1;
    },
    paintInterior$4$textDirection(canvas, rect, paint, textDirection) {
      canvas.drawRRect$2(this.borderRadius.toRRect$1(rect), paint);
    },
    get$preferPaintInterior() {
      return true;
    },
    paint$6$gapExtent$gapPercentage$gapStart$textDirection(canvas, rect, gapExtent, gapPercentage, gapStart, textDirection) {
      var center, t2, t3, t4, scaledRRect, t5, t6, t7, t8, t9, t10, t11, t12, t13, trCorner, t14, t15, t16, t17, t18, t19, t20, t21, t22, path, sweep,
        t1 = this.borderSide,
        paint = t1.toPaint$0(),
        outer = this.borderRadius.toRRect$1(rect);
      t1 = t1.width / 2;
      center = outer.inflate$1(-t1);
      if (gapStart == null || gapExtent <= 0 || gapPercentage === 0)
        canvas.drawRRect$2(center, paint);
      else {
        t2 = this.gapPadding;
        t3 = B.lerpDouble(0, gapExtent + t2 * 2, gapPercentage);
        t3.toString;
        switch (textDirection.index) {
          case 0:
            t2 = gapStart + t2 - t3;
            break;
          case 1:
            t2 = gapStart - t2;
            break;
          default:
            t2 = null;
        }
        t4 = outer.right - outer.left;
        t2 = Math.max(0, t2);
        scaledRRect = center.scaleRadii$0();
        t5 = scaledRRect.left;
        t6 = scaledRRect.top;
        t7 = scaledRRect.tlRadiusX;
        t8 = scaledRRect.tlRadiusY;
        t9 = scaledRRect.right;
        t10 = scaledRRect.trRadiusX;
        t11 = t10 * 2;
        t12 = t9 - t11;
        t13 = scaledRRect.trRadiusY;
        trCorner = new B.Rect(t12, t6, t12 + t11, t6 + t13 * 2);
        t11 = scaledRRect.brRadiusX;
        t12 = t11 * 2;
        t14 = t9 - t12;
        t15 = scaledRRect.bottom;
        t16 = scaledRRect.brRadiusY;
        t17 = t16 * 2;
        t18 = t15 - t17;
        t19 = scaledRRect.blRadiusY;
        t20 = t19 * 2;
        t21 = t15 - t20;
        t22 = scaledRRect.blRadiusX;
        path = $.$get$_renderer().createPath$0();
        if (!new B.Radius(t7, t8).$eq(0, A.Radius_0_0))
          path.addArc$3(new B.Rect(t5, t6, t5 + t7 * 2, t6 + t8 * 2), 3.141592653589793, Math.acos(B.clampDouble(1 - t2 / t7, 0, 1)));
        else
          path.moveTo$2(t5 - t1, t6);
        if (t2 > t7)
          path.lineTo$2(t2, t6);
        t1 = t2 + t3;
        if (t1 < t4 - t10) {
          path.moveTo$2(t1, t6);
          path.lineTo$2(t9 - t10, t6);
          if (!new B.Radius(t10, t13).$eq(0, A.Radius_0_0))
            path.addArc$3(trCorner, 4.71238898038469, 1.5707963267948966);
        } else if (t1 < t4) {
          sweep = Math.asin(B.clampDouble(1 - (t4 - t1) / t10, 0, 1));
          path.addArc$3(trCorner, 4.71238898038469 + sweep, 1.5707963267948966 - sweep);
        }
        if (!new B.Radius(t11, t16).$eq(0, A.Radius_0_0))
          path.moveTo$2(t9, t6 + t13);
        path.lineTo$2(t9, t15 - t16);
        if (!new B.Radius(t11, t16).$eq(0, A.Radius_0_0))
          path.addArc$3(new B.Rect(t14, t18, t14 + t12, t18 + t17), 0, 1.5707963267948966);
        path.lineTo$2(t5 + t22, t15);
        if (!new B.Radius(t22, t19).$eq(0, A.Radius_0_0))
          path.addArc$3(new B.Rect(t5, t21, t5 + t22 * 2, t21 + t20), 1.5707963267948966, 1.5707963267948966);
        path.lineTo$2(t5, t6 + t8);
        canvas.drawPath$2(path, paint);
      }
    },
    paint$3$textDirection(canvas, rect, textDirection) {
      return this.paint$6$gapExtent$gapPercentage$gapStart$textDirection(canvas, rect, 0, 0, null, textDirection);
    },
    $eq(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (J.get$runtimeType$(other) !== B.getRuntimeTypeOfDartObject(_this))
        return false;
      return other instanceof C.OutlineInputBorder && other.borderSide.$eq(0, _this.borderSide) && other.borderRadius.$eq(0, _this.borderRadius) && other.gapPadding === _this.gapPadding;
    },
    get$hashCode(_) {
      return B.Object_hash(this.borderSide, this.borderRadius, this.gapPadding, A.C_SentinelValue, A.C_SentinelValue, A.C_SentinelValue, A.C_SentinelValue, A.C_SentinelValue, A.C_SentinelValue, A.C_SentinelValue, A.C_SentinelValue, A.C_SentinelValue, A.C_SentinelValue, A.C_SentinelValue, A.C_SentinelValue, A.C_SentinelValue, A.C_SentinelValue, A.C_SentinelValue, A.C_SentinelValue, A.C_SentinelValue);
    }
  };
  var typesOffset = hunkHelpers.updateTypes([]);
  (function inheritance() {
    var _inherit = hunkHelpers.inherit;
    _inherit(C.OutlineInputBorder, D.InputBorder);
  })();
  B._Universe_addRules(init.typeUniverse, JSON.parse('{"OutlineInputBorder":{"InputBorder":[],"ShapeBorder":[]}}'));
};
;
((d, h) => {
  d[h] = d.current;
  d.eventLog.push({p: "main.dart.js_7", e: "endPart", h: h});
})($__dart_deferred_initializers__, "TXmiK8JU6yRTguAQVUlBdTSdx/o=");
;